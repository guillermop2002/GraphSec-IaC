{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/main/sarif-2.1/schema/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "Checkov", "version": "3.2.489", "informationUri": "https://checkov.io", "rules": [{"id": "CKV_TF_1", "name": "Ensure Terraform module sources use a commit hash", "shortDescription": {"text": "Ensure Terraform module sources use a commit hash"}, "fullDescription": {"text": "Ensure Terraform module sources use a commit hash"}, "help": {"text": "Ensure Terraform module sources use a commit hash\nResource: vpc"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/supply-chain-policies/terraform-policies/ensure-terraform-module-sources-use-git-url-with-commit-hash-revision"}, {"id": "CKV_AWS_126", "name": "Ensure that detailed monitoring is enabled for EC2 instances", "shortDescription": {"text": "Ensure that detailed monitoring is enabled for EC2 instances"}, "fullDescription": {"text": "Ensure that detailed monitoring is enabled for EC2 instances"}, "help": {"text": "Ensure that detailed monitoring is enabled for EC2 instances\nResource: aws_instance.hybrid_node[\"one\"]"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-logging-policies/ensure-that-detailed-monitoring-is-enabled-for-ec2-instances"}, {"id": "CKV_AWS_135", "name": "Ensure that EC2 is EBS optimized", "shortDescription": {"text": "Ensure that EC2 is EBS optimized"}, "fullDescription": {"text": "Ensure that EC2 is EBS optimized"}, "help": {"text": "Ensure that EC2 is EBS optimized\nResource: aws_instance.hybrid_node[\"one\"]"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-general-policies/ensure-that-ec2-is-ebs-optimized"}, {"id": "CKV_AWS_88", "name": "EC2 instance should not have public IP.", "shortDescription": {"text": "EC2 instance should not have public IP."}, "fullDescription": {"text": "EC2 instance should not have public IP."}, "help": {"text": "EC2 instance should not have public IP.\nResource: aws_instance.hybrid_node[\"one\"]"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/public-policies/public-12"}, {"id": "CKV_AWS_8", "name": "Ensure all data stored in the Launch configuration or instance Elastic Blocks Store is securely encrypted", "shortDescription": {"text": "Ensure all data stored in the Launch configuration or instance Elastic Blocks Store is securely encrypted"}, "fullDescription": {"text": "Ensure all data stored in the Launch configuration or instance Elastic Blocks Store is securely encrypted"}, "help": {"text": "Ensure all data stored in the Launch configuration or instance Elastic Blocks Store is securely encrypted\nResource: aws_instance.hybrid_node[\"one\"]"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-general-policies/general-13"}, {"id": "CKV_AWS_23", "name": "Ensure every security group and rule has a description", "shortDescription": {"text": "Ensure every security group and rule has a description"}, "fullDescription": {"text": "Ensure every security group and rule has a description"}, "help": {"text": "Ensure every security group and rule has a description\nResource: aws_security_group.remote_node"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-networking-policies/networking-31"}, {"id": "CKV_AWS_37", "name": "Ensure Amazon EKS control plane logging is enabled for all log types", "shortDescription": {"text": "Ensure Amazon EKS control plane logging is enabled for all log types"}, "fullDescription": {"text": "Ensure Amazon EKS control plane logging is enabled for all log types"}, "help": {"text": "Ensure Amazon EKS control plane logging is enabled for all log types\nResource: module.disabled_eks.aws_eks_cluster.this[0]"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-kubernetes-policies/bc-aws-kubernetes-4"}, {"id": "CKV_AWS_58", "name": "Ensure EKS Cluster has Secrets Encryption Enabled", "shortDescription": {"text": "Ensure EKS Cluster has Secrets Encryption Enabled"}, "fullDescription": {"text": "Ensure EKS Cluster has Secrets Encryption Enabled"}, "help": {"text": "Ensure EKS Cluster has Secrets Encryption Enabled\nResource: module.disabled_eks.aws_eks_cluster.this[0]"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-kubernetes-policies/bc-aws-kubernetes-3"}, {"id": "CKV_AWS_338", "name": "Ensure CloudWatch log groups retains logs for at least 1 year", "shortDescription": {"text": "Ensure CloudWatch log groups retains logs for at least 1 year"}, "fullDescription": {"text": "Ensure CloudWatch log groups retains logs for at least 1 year"}, "help": {"text": "Ensure CloudWatch log groups retains logs for at least 1 year\nResource: module.disabled_eks.aws_cloudwatch_log_group.this[0]"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-logging-policies/bc-aws-338"}, {"id": "CKV_AWS_39", "name": "Ensure Amazon EKS public endpoint disabled", "shortDescription": {"text": "Ensure Amazon EKS public endpoint disabled"}, "fullDescription": {"text": "Ensure Amazon EKS public endpoint disabled"}, "help": {"text": "Ensure Amazon EKS public endpoint disabled\nResource: module.eks.aws_eks_cluster.this"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-kubernetes-policies/bc-aws-kubernetes-2"}, {"id": "CKV_AWS_38", "name": "Ensure Amazon EKS public endpoint not accessible to 0.0.0.0/0", "shortDescription": {"text": "Ensure Amazon EKS public endpoint not accessible to 0.0.0.0/0"}, "fullDescription": {"text": "Ensure Amazon EKS public endpoint not accessible to 0.0.0.0/0"}, "help": {"text": "Ensure Amazon EKS public endpoint not accessible to 0.0.0.0/0\nResource: module.eks.aws_eks_cluster.this"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-kubernetes-policies/bc-aws-kubernetes-1"}, {"id": "CKV_AWS_79", "name": "Ensure Instance Metadata Service Version 1 is not enabled", "shortDescription": {"text": "Ensure Instance Metadata Service Version 1 is not enabled"}, "fullDescription": {"text": "Ensure Instance Metadata Service Version 1 is not enabled"}, "help": {"text": "Ensure Instance Metadata Service Version 1 is not enabled\nResource: module.disabled_eks.module.eks_managed_node_group.aws_launch_template.this"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-general-policies/bc-aws-general-31"}, {"id": "CKV_AWS_341", "name": "Ensure Launch template should not have a metadata response hop limit greater than 1", "shortDescription": {"text": "Ensure Launch template should not have a metadata response hop limit greater than 1"}, "fullDescription": {"text": "Ensure Launch template should not have a metadata response hop limit greater than 1"}, "help": {"text": "Ensure Launch template should not have a metadata response hop limit greater than 1\nResource: module.disabled_eks.module.eks_managed_node_group.aws_launch_template.this"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-general-policies/bc-aws-341"}, {"id": "CKV_AWS_111", "name": "Ensure IAM policies does not allow write access without constraints", "shortDescription": {"text": "Ensure IAM policies does not allow write access without constraints"}, "fullDescription": {"text": "Ensure IAM policies does not allow write access without constraints"}, "help": {"text": "Ensure IAM policies does not allow write access without constraints\nResource: module.eks_hybrid_node_role.aws_iam_policy_document.this"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-iam-policies/ensure-iam-policies-do-not-allow-write-access-without-constraint"}, {"id": "CKV_AWS_356", "name": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions", "shortDescription": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions"}, "fullDescription": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions"}, "help": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions\nResource: module.eks_hybrid_node_role.aws_iam_policy_document.this"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-iam-policies/bc-aws-356"}, {"id": "CKV_AWS_355", "name": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions", "shortDescription": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions"}, "fullDescription": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions"}, "help": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions\nResource: aws_iam_policy.additional"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-iam-policies/bc-aws-355"}, {"id": "CKV_AWS_382", "name": "Ensure no security groups allow egress from 0.0.0.0:0 to port -1", "shortDescription": {"text": "Ensure no security groups allow egress from 0.0.0.0:0 to port -1"}, "fullDescription": {"text": "Ensure no security groups allow egress from 0.0.0.0:0 to port -1"}, "help": {"text": "Ensure no security groups allow egress from 0.0.0.0:0 to port -1\nResource: aws_security_group.remote_access"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-networking-policies/bc-aws-382"}, {"id": "CKV2_AWS_41", "name": "Ensure an IAM role is attached to EC2 instance", "shortDescription": {"text": "Ensure an IAM role is attached to EC2 instance"}, "fullDescription": {"text": "Ensure an IAM role is attached to EC2 instance"}, "help": {"text": "Ensure an IAM role is attached to EC2 instance\nResource: aws_instance.hybrid_node[\"one\"]"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-iam-policies/ensure-an-iam-role-is-attached-to-ec2-instance"}, {"id": "CKV2_AWS_5", "name": "Ensure that Security Groups are attached to another resource", "shortDescription": {"text": "Ensure that Security Groups are attached to another resource"}, "fullDescription": {"text": "Ensure that Security Groups are attached to another resource"}, "help": {"text": "Ensure that Security Groups are attached to another resource\nResource: module.disabled_eks.aws_security_group.cluster[0]"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-networking-policies/ensure-that-security-groups-are-attached-to-ec2-instances-or-elastic-network-interfaces-enis"}, {"id": "CKV_K8S_20", "name": "Containers should not run with allowPrivilegeEscalation", "shortDescription": {"text": "Containers should not run with allowPrivilegeEscalation"}, "fullDescription": {"text": "Containers should not run with allowPrivilegeEscalation"}, "help": {"text": "Containers should not run with allowPrivilegeEscalation\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-19"}, {"id": "CKV_K8S_30", "name": "Apply security context to your containers", "shortDescription": {"text": "Apply security context to your containers"}, "fullDescription": {"text": "Apply security context to your containers"}, "help": {"text": "Apply security context to your containers\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-28"}, {"id": "CKV_K8S_11", "name": "CPU limits should be set", "shortDescription": {"text": "CPU limits should be set"}, "fullDescription": {"text": "CPU limits should be set"}, "help": {"text": "CPU limits should be set\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-10"}, {"id": "CKV_K8S_21", "name": "The default namespace should not be used", "shortDescription": {"text": "The default namespace should not be used"}, "fullDescription": {"text": "The default namespace should not be used"}, "help": {"text": "The default namespace should not be used\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-20"}, {"id": "CKV_K8S_28", "name": "Minimize the admission of containers with the NET_RAW capability", "shortDescription": {"text": "Minimize the admission of containers with the NET_RAW capability"}, "fullDescription": {"text": "Minimize the admission of containers with the NET_RAW capability"}, "help": {"text": "Minimize the admission of containers with the NET_RAW capability\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-27"}, {"id": "CKV_K8S_43", "name": "Image should use digest", "shortDescription": {"text": "Image should use digest"}, "fullDescription": {"text": "Image should use digest"}, "help": {"text": "Image should use digest\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-39"}, {"id": "CKV_K8S_15", "name": "Image Pull Policy should be Always", "shortDescription": {"text": "Image Pull Policy should be Always"}, "fullDescription": {"text": "Image Pull Policy should be Always"}, "help": {"text": "Image Pull Policy should be Always\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-14"}, {"id": "CKV_K8S_8", "name": "Liveness Probe Should be Configured", "shortDescription": {"text": "Liveness Probe Should be Configured"}, "fullDescription": {"text": "Liveness Probe Should be Configured"}, "help": {"text": "Liveness Probe Should be Configured\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-7"}, {"id": "CKV_K8S_13", "name": "Memory limits should be set", "shortDescription": {"text": "Memory limits should be set"}, "fullDescription": {"text": "Memory limits should be set"}, "help": {"text": "Memory limits should be set\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-12"}, {"id": "CKV_K8S_12", "name": "Memory requests should be set", "shortDescription": {"text": "Memory requests should be set"}, "fullDescription": {"text": "Memory requests should be set"}, "help": {"text": "Memory requests should be set\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-11"}, {"id": "CKV_K8S_37", "name": "Minimize the admission of containers with capabilities assigned", "shortDescription": {"text": "Minimize the admission of containers with capabilities assigned"}, "fullDescription": {"text": "Minimize the admission of containers with capabilities assigned"}, "help": {"text": "Minimize the admission of containers with capabilities assigned\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-34"}, {"id": "CKV_K8S_29", "name": "Apply security context to your pods and containers", "shortDescription": {"text": "Apply security context to your pods and containers"}, "fullDescription": {"text": "Apply security context to your pods and containers"}, "help": {"text": "Apply security context to your pods and containers\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/ensure-securitycontext-is-applied-to-pods-and-containers"}, {"id": "CKV_K8S_9", "name": "Readiness Probe Should be Configured", "shortDescription": {"text": "Readiness Probe Should be Configured"}, "fullDescription": {"text": "Readiness Probe Should be Configured"}, "help": {"text": "Readiness Probe Should be Configured\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-8"}, {"id": "CKV_K8S_22", "name": "Use read-only filesystem for containers where possible", "shortDescription": {"text": "Use read-only filesystem for containers where possible"}, "fullDescription": {"text": "Use read-only filesystem for containers where possible"}, "help": {"text": "Use read-only filesystem for containers where possible\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-21"}, {"id": "CKV_K8S_23", "name": "Minimize the admission of root containers", "shortDescription": {"text": "Minimize the admission of root containers"}, "fullDescription": {"text": "Minimize the admission of root containers"}, "help": {"text": "Minimize the admission of root containers\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-22"}, {"id": "CKV_K8S_40", "name": "Containers should run as a high UID to avoid host conflict", "shortDescription": {"text": "Containers should run as a high UID to avoid host conflict"}, "fullDescription": {"text": "Containers should run as a high UID to avoid host conflict"}, "help": {"text": "Containers should run as a high UID to avoid host conflict\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-37"}, {"id": "CKV_K8S_31", "name": "Ensure that the seccomp profile is set to docker/default or runtime/default", "shortDescription": {"text": "Ensure that the seccomp profile is set to docker/default or runtime/default"}, "fullDescription": {"text": "Ensure that the seccomp profile is set to docker/default or runtime/default"}, "help": {"text": "Ensure that the seccomp profile is set to docker/default or runtime/default\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-29"}, {"id": "CKV_K8S_38", "name": "Ensure that Service Account Tokens are only mounted where necessary", "shortDescription": {"text": "Ensure that Service Account Tokens are only mounted where necessary"}, "fullDescription": {"text": "Ensure that Service Account Tokens are only mounted where necessary"}, "help": {"text": "Ensure that Service Account Tokens are only mounted where necessary\nResource: Deployment.default.inflate"}, "defaultConfiguration": {"level": "error"}, "helpUri": "https://docs.prismacloud.io/en/enterprise-edition/policy-reference/kubernetes-policies/kubernetes-policy-index/bc-k8s-35"}, {"id": "CKV2_K8S_6", "name": "Minimize the admission of pods which lack an associated NetworkPolicy", "shortDescription": {"text": "Minimize the admission of pods which lack an associated NetworkPolicy"}, "fullDescription": {"text": "Minimize the admission of pods which lack an associated NetworkPolicy"}, "help": {"text": "Minimize the admission of pods which lack an associated NetworkPolicy\nResource: Pod.default.inflate.app-inflate"}, "defaultConfiguration": {"level": "error"}}, {"id": "CKV2_GHA_1", "name": "Ensure top-level permissions are not set to write-all", "shortDescription": {"text": "Ensure top-level permissions are not set to write-all"}, "fullDescription": {"text": "Ensure top-level permissions are not set to write-all"}, "help": {"text": "Ensure top-level permissions are not set to write-all\nResource: on(Lock Threads)"}, "defaultConfiguration": {"level": "error"}}], "organization": "bridgecrew"}}, "results": [{"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/main.tf"}, "region": {"startLine": 83, "endLine": 107, "snippet": {"text": "module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 6.0\"\n\n  name = local.name\n  cidr = local.vpc_cidr\n\n  azs             = local.azs\n  private_subnets = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 4, k)]\n  public_subnets  = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 48)]\n  intra_subnets   = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 52)]\n\n  enable_nat_gateway = true\n  single_nat_gateway = true\n\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = 1\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = 1\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/main.tf"}, "region": {"startLine": 107, "endLine": 131, "snippet": {"text": "module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 6.0\"\n\n  name = local.name\n  cidr = local.vpc_cidr\n\n  azs             = local.azs\n  private_subnets = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 4, k)]\n  public_subnets  = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 48)]\n  intra_subnets   = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 52)]\n\n  enable_nat_gateway = true\n  single_nat_gateway = true\n\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = 1\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = 1\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 30, "endLine": 42, "snippet": {"text": "module \"key_pair\" {\n  source  = \"terraform-aws-modules/key-pair/aws\"\n  version = \"~> 2.0\"\n\n  providers = {\n    aws = aws.remote\n  }\n\n  key_name           = \"hybrid-node\"\n  create_private_key = true\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 254, "endLine": 278, "snippet": {"text": "module \"remote_node_vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 6.0\"\n\n  providers = {\n    aws = aws.remote\n  }\n\n  name = local.name\n  cidr = local.remote_network_cidr\n\n  azs             = local.remote_node_azs\n  private_subnets = [for k, v in local.remote_node_azs : cidrsubnet(local.remote_network_cidr, 4, k)]\n  public_subnets  = [for k, v in local.remote_node_azs : cidrsubnet(local.remote_network_cidr, 8, k + 48)]\n\n  public_subnet_tags = {\n    # For building the AMI\n    \"eks-hybrid-packer\" : \"true\"\n  }\n\n  enable_nat_gateway = true\n  single_nat_gateway = true\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_AWS_126", "ruleIndex": 1, "level": "error", "attachments": [], "message": {"text": "Ensure that detailed monitoring is enabled for EC2 instances"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 97, "endLine": 118, "snippet": {"text": "resource \"aws_instance\" \"hybrid_node\" {\n  provider = aws.remote\n\n  for_each = { one = 0, two = 1 }\n\n  ami                         = data.aws_ami.hybrid_node.id\n  associate_public_ip_address = true\n  instance_type               = \"m5.large\"\n\n  # Block IMDS to make instance look less like EC2 and more like vanilla VM\n  metadata_options {\n    http_endpoint = \"disabled\"\n  }\n\n  vpc_security_group_ids = [aws_security_group.remote_node.id]\n  subnet_id              = element(module.remote_node_vpc.public_subnets, each.value)\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_135", "ruleIndex": 2, "level": "error", "attachments": [], "message": {"text": "Ensure that EC2 is EBS optimized"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 97, "endLine": 118, "snippet": {"text": "resource \"aws_instance\" \"hybrid_node\" {\n  provider = aws.remote\n\n  for_each = { one = 0, two = 1 }\n\n  ami                         = data.aws_ami.hybrid_node.id\n  associate_public_ip_address = true\n  instance_type               = \"m5.large\"\n\n  # Block IMDS to make instance look less like EC2 and more like vanilla VM\n  metadata_options {\n    http_endpoint = \"disabled\"\n  }\n\n  vpc_security_group_ids = [aws_security_group.remote_node.id]\n  subnet_id              = element(module.remote_node_vpc.public_subnets, each.value)\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_88", "ruleIndex": 3, "level": "error", "attachments": [], "message": {"text": "EC2 instance should not have public IP."}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 97, "endLine": 118, "snippet": {"text": "resource \"aws_instance\" \"hybrid_node\" {\n  provider = aws.remote\n\n  for_each = { one = 0, two = 1 }\n\n  ami                         = data.aws_ami.hybrid_node.id\n  associate_public_ip_address = true\n  instance_type               = \"m5.large\"\n\n  # Block IMDS to make instance look less like EC2 and more like vanilla VM\n  metadata_options {\n    http_endpoint = \"disabled\"\n  }\n\n  vpc_security_group_ids = [aws_security_group.remote_node.id]\n  subnet_id              = element(module.remote_node_vpc.public_subnets, each.value)\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_8", "ruleIndex": 4, "level": "error", "attachments": [], "message": {"text": "Ensure all data stored in the Launch configuration or instance Elastic Blocks Store is securely encrypted"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 97, "endLine": 118, "snippet": {"text": "resource \"aws_instance\" \"hybrid_node\" {\n  provider = aws.remote\n\n  for_each = { one = 0, two = 1 }\n\n  ami                         = data.aws_ami.hybrid_node.id\n  associate_public_ip_address = true\n  instance_type               = \"m5.large\"\n\n  # Block IMDS to make instance look less like EC2 and more like vanilla VM\n  metadata_options {\n    http_endpoint = \"disabled\"\n  }\n\n  vpc_security_group_ids = [aws_security_group.remote_node.id]\n  subnet_id              = element(module.remote_node_vpc.public_subnets, each.value)\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_23", "ruleIndex": 5, "level": "error", "attachments": [], "message": {"text": "Ensure every security group and rule has a description"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 130, "endLine": 141, "snippet": {"text": "resource \"aws_security_group\" \"remote_node\" {\n  provider = aws.remote\n\n  name                   = \"hybrid-node\"\n  vpc_id                 = module.remote_node_vpc.vpc_id\n  revoke_rules_on_delete = true\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_23", "ruleIndex": 5, "level": "error", "attachments": [], "message": {"text": "Ensure every security group and rule has a description"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 143, "endLine": 177, "snippet": {"text": "resource \"aws_vpc_security_group_ingress_rule\" \"remote_node\" {\n  provider = aws.remote\n\n  for_each = {\n    cluster-all = {\n      description = \"Allow all traffic from cluster network\"\n      cidr_ipv4   = module.vpc.vpc_cidr_block\n      ip_protocol = \"all\"\n    }\n    remote-all = {\n      description                  = \"Allow all traffic from within the remote network itself\"\n      ip_protocol                  = \"all\"\n      referenced_security_group_id = aws_security_group.remote_node.id\n    }\n    # Restrict SSH access to only the IP where Terraform is running\n    ssh = {\n      description = \"Local SSH access to join node to cluster\"\n      cidr_ipv4   = \"${chomp(data.http.icanhazip.response_body)}/32\"\n      from_port   = \"22\"\n      ip_protocol = \"tcp\"\n    }\n  }\n\n  cidr_ipv4                    = try(each.value.cidr_ipv4, null)\n  from_port                    = try(each.value.from_port, null)\n  ip_protocol                  = try(each.value.ip_protocol, null)\n  to_port                      = try(each.value.to_port, each.value.from_port, null)\n  referenced_security_group_id = try(each.value.referenced_security_group_id, null)\n  security_group_id            = aws_security_group.remote_node.id\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_23", "ruleIndex": 5, "level": "error", "attachments": [], "message": {"text": "Ensure every security group and rule has a description"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 179, "endLine": 201, "snippet": {"text": "resource \"aws_vpc_security_group_egress_rule\" \"remote_node\" {\n  provider = aws.remote\n\n  for_each = {\n    all = {\n      description = \"Allow all egress\"\n      cidr_ipv4   = \"0.0.0.0/0\"\n      ip_protocol = \"all\"\n    }\n  }\n\n  cidr_ipv4                    = try(each.value.cidr_ipv4, null)\n  from_port                    = try(each.value.from_port, null)\n  ip_protocol                  = try(each.value.ip_protocol, null)\n  to_port                      = try(each.value.to_port, each.value.from_port, null)\n  referenced_security_group_id = try(each.value.referenced_security_group_id, null)\n  security_group_id            = aws_security_group.remote_node.id\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_126", "ruleIndex": 1, "level": "error", "attachments": [], "message": {"text": "Ensure that detailed monitoring is enabled for EC2 instances"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 97, "endLine": 118, "snippet": {"text": "resource \"aws_instance\" \"hybrid_node\" {\n  provider = aws.remote\n\n  for_each = { one = 0, two = 1 }\n\n  ami                         = data.aws_ami.hybrid_node.id\n  associate_public_ip_address = true\n  instance_type               = \"m5.large\"\n\n  # Block IMDS to make instance look less like EC2 and more like vanilla VM\n  metadata_options {\n    http_endpoint = \"disabled\"\n  }\n\n  vpc_security_group_ids = [aws_security_group.remote_node.id]\n  subnet_id              = element(module.remote_node_vpc.public_subnets, each.value)\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_135", "ruleIndex": 2, "level": "error", "attachments": [], "message": {"text": "Ensure that EC2 is EBS optimized"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 97, "endLine": 118, "snippet": {"text": "resource \"aws_instance\" \"hybrid_node\" {\n  provider = aws.remote\n\n  for_each = { one = 0, two = 1 }\n\n  ami                         = data.aws_ami.hybrid_node.id\n  associate_public_ip_address = true\n  instance_type               = \"m5.large\"\n\n  # Block IMDS to make instance look less like EC2 and more like vanilla VM\n  metadata_options {\n    http_endpoint = \"disabled\"\n  }\n\n  vpc_security_group_ids = [aws_security_group.remote_node.id]\n  subnet_id              = element(module.remote_node_vpc.public_subnets, each.value)\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_88", "ruleIndex": 3, "level": "error", "attachments": [], "message": {"text": "EC2 instance should not have public IP."}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 97, "endLine": 118, "snippet": {"text": "resource \"aws_instance\" \"hybrid_node\" {\n  provider = aws.remote\n\n  for_each = { one = 0, two = 1 }\n\n  ami                         = data.aws_ami.hybrid_node.id\n  associate_public_ip_address = true\n  instance_type               = \"m5.large\"\n\n  # Block IMDS to make instance look less like EC2 and more like vanilla VM\n  metadata_options {\n    http_endpoint = \"disabled\"\n  }\n\n  vpc_security_group_ids = [aws_security_group.remote_node.id]\n  subnet_id              = element(module.remote_node_vpc.public_subnets, each.value)\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_8", "ruleIndex": 4, "level": "error", "attachments": [], "message": {"text": "Ensure all data stored in the Launch configuration or instance Elastic Blocks Store is securely encrypted"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 97, "endLine": 118, "snippet": {"text": "resource \"aws_instance\" \"hybrid_node\" {\n  provider = aws.remote\n\n  for_each = { one = 0, two = 1 }\n\n  ami                         = data.aws_ami.hybrid_node.id\n  associate_public_ip_address = true\n  instance_type               = \"m5.large\"\n\n  # Block IMDS to make instance look less like EC2 and more like vanilla VM\n  metadata_options {\n    http_endpoint = \"disabled\"\n  }\n\n  vpc_security_group_ids = [aws_security_group.remote_node.id]\n  subnet_id              = element(module.remote_node_vpc.public_subnets, each.value)\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_23", "ruleIndex": 5, "level": "error", "attachments": [], "message": {"text": "Ensure every security group and rule has a description"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 143, "endLine": 177, "snippet": {"text": "resource \"aws_vpc_security_group_ingress_rule\" \"remote_node\" {\n  provider = aws.remote\n\n  for_each = {\n    cluster-all = {\n      description = \"Allow all traffic from cluster network\"\n      cidr_ipv4   = module.vpc.vpc_cidr_block\n      ip_protocol = \"all\"\n    }\n    remote-all = {\n      description                  = \"Allow all traffic from within the remote network itself\"\n      ip_protocol                  = \"all\"\n      referenced_security_group_id = aws_security_group.remote_node.id\n    }\n    # Restrict SSH access to only the IP where Terraform is running\n    ssh = {\n      description = \"Local SSH access to join node to cluster\"\n      cidr_ipv4   = \"${chomp(data.http.icanhazip.response_body)}/32\"\n      from_port   = \"22\"\n      ip_protocol = \"tcp\"\n    }\n  }\n\n  cidr_ipv4                    = try(each.value.cidr_ipv4, null)\n  from_port                    = try(each.value.from_port, null)\n  ip_protocol                  = try(each.value.ip_protocol, null)\n  to_port                      = try(each.value.to_port, each.value.from_port, null)\n  referenced_security_group_id = try(each.value.referenced_security_group_id, null)\n  security_group_id            = aws_security_group.remote_node.id\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_23", "ruleIndex": 5, "level": "error", "attachments": [], "message": {"text": "Ensure every security group and rule has a description"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 143, "endLine": 177, "snippet": {"text": "resource \"aws_vpc_security_group_ingress_rule\" \"remote_node\" {\n  provider = aws.remote\n\n  for_each = {\n    cluster-all = {\n      description = \"Allow all traffic from cluster network\"\n      cidr_ipv4   = module.vpc.vpc_cidr_block\n      ip_protocol = \"all\"\n    }\n    remote-all = {\n      description                  = \"Allow all traffic from within the remote network itself\"\n      ip_protocol                  = \"all\"\n      referenced_security_group_id = aws_security_group.remote_node.id\n    }\n    # Restrict SSH access to only the IP where Terraform is running\n    ssh = {\n      description = \"Local SSH access to join node to cluster\"\n      cidr_ipv4   = \"${chomp(data.http.icanhazip.response_body)}/32\"\n      from_port   = \"22\"\n      ip_protocol = \"tcp\"\n    }\n  }\n\n  cidr_ipv4                    = try(each.value.cidr_ipv4, null)\n  from_port                    = try(each.value.from_port, null)\n  ip_protocol                  = try(each.value.ip_protocol, null)\n  to_port                      = try(each.value.to_port, each.value.from_port, null)\n  referenced_security_group_id = try(each.value.referenced_security_group_id, null)\n  security_group_id            = aws_security_group.remote_node.id\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-managed-node-group/eks-al2023.tf"}, "region": {"startLine": 1, "endLine": 55, "snippet": {"text": "module \"eks_al2023\" {\n  source  = \"terraform-aws-modules/eks/aws\"\n  version = \"~> 21.0\"\n\n  name               = \"${local.name}-al2023\"\n  kubernetes_version = \"1.33\"\n\n  # EKS Addons\n  addons = {\n    coredns = {}\n    eks-pod-identity-agent = {\n      before_compute = true\n    }\n    kube-proxy = {}\n    vpc-cni = {\n      before_compute = true\n    }\n  }\n\n  vpc_id     = module.vpc.vpc_id\n  subnet_ids = module.vpc.private_subnets\n\n  eks_managed_node_groups = {\n    example = {\n      # Starting on 1.30, AL2023 is the default AMI type for EKS managed node groups\n      instance_types = [\"m6i.large\"]\n      ami_type       = \"AL2023_x86_64_STANDARD\"\n\n      min_size = 2\n      max_size = 5\n      # This value is ignored after the initial creation\n      # https://github.com/bryantbiggs/eks-desired-size-hack\n      desired_size = 2\n\n      # This is not required - demonstrates how to pass additional configuration to nodeadm\n      # Ref https://awslabs.github.io/amazon-eks-ami/nodeadm/doc/api/\n      cloudinit_pre_nodeadm = [\n        {\n          content_type = \"application/node.eks.aws\"\n          content      = <<-EOT\n            ---\n            apiVersion: node.eks.aws/v1alpha1\n            kind: NodeConfig\n            spec:\n              kubelet:\n                config:\n                  shutdownGracePeriod: 30s\n          EOT\n        }\n      ]\n    }\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-managed-node-group/eks-bottlerocket.tf"}, "region": {"startLine": 1, "endLine": 56, "snippet": {"text": "module \"eks_bottlerocket\" {\n  source  = \"terraform-aws-modules/eks/aws\"\n  version = \"~> 21.0\"\n\n  name               = \"${local.name}-bottlerocket\"\n  kubernetes_version = \"1.33\"\n\n  # EKS Addons\n  addons = {\n    coredns = {}\n    eks-pod-identity-agent = {\n      before_compute = true\n    }\n    kube-proxy = {}\n    vpc-cni = {\n      before_compute = true\n    }\n  }\n\n  vpc_id     = module.vpc.vpc_id\n  subnet_ids = module.vpc.private_subnets\n\n  eks_managed_node_groups = {\n    example = {\n      ami_type       = \"BOTTLEROCKET_x86_64\"\n      instance_types = [\"m6i.large\"]\n\n      min_size = 2\n      max_size = 5\n      # This value is ignored after the initial creation\n      # https://github.com/bryantbiggs/eks-desired-size-hack\n      desired_size = 2\n\n      # This is not required - demonstrates how to pass additional configuration\n      # Ref https://bottlerocket.dev/en/os/1.19.x/api/settings/\n      bootstrap_extra_args = <<-EOT\n        # The admin host container provides SSH access and runs with \"superpowers\".\n        # It is disabled by default, but can be disabled explicitly.\n        [settings.host-containers.admin]\n        enabled = false\n\n        # The control host container provides out-of-band access via SSM.\n        # It is enabled by default, and can be disabled if you do not expect to use SSM.\n        # This could leave you with no way to access the API and change settings on an existing node!\n        [settings.host-containers.control]\n        enabled = true\n\n        # extra args added\n        [settings.kernel]\n        lockdown = \"integrity\"\n      EOT\n    }\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-managed-node-group/main.tf"}, "region": {"startLine": 31, "endLine": 55, "snippet": {"text": "module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 6.0\"\n\n  name = local.name\n  cidr = local.vpc_cidr\n\n  azs             = local.azs\n  private_subnets = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 4, k)]\n  public_subnets  = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 48)]\n  intra_subnets   = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 52)]\n\n  enable_nat_gateway = true\n  single_nat_gateway = true\n\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = 1\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = 1\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/main.tf"}, "region": {"startLine": 163, "endLine": 189, "snippet": {"text": "module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 6.0\"\n\n  name = local.name\n  cidr = local.vpc_cidr\n\n  azs             = local.azs\n  private_subnets = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 4, k)]\n  public_subnets  = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 48)]\n  intra_subnets   = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 52)]\n\n  enable_nat_gateway = true\n  single_nat_gateway = true\n\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = 1\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = 1\n    # Tags subnets for Karpenter auto-discovery\n    \"karpenter.sh/discovery\" = local.name\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/self-managed-node-group/eks-al2023.tf"}, "region": {"startLine": 1, "endLine": 54, "snippet": {"text": "module \"eks_al2023\" {\n  source  = \"terraform-aws-modules/eks/aws\"\n  version = \"~> 21.0\"\n\n  name               = \"${local.name}-al2023\"\n  kubernetes_version = \"1.33\"\n\n  # EKS Addons\n  addons = {\n    coredns = {}\n    eks-pod-identity-agent = {\n      before_compute = true\n    }\n    kube-proxy = {}\n    vpc-cni = {\n      before_compute = true\n    }\n  }\n\n  vpc_id     = module.vpc.vpc_id\n  subnet_ids = module.vpc.private_subnets\n\n  self_managed_node_groups = {\n    example = {\n      ami_type      = \"AL2023_x86_64_STANDARD\"\n      instance_type = \"m6i.large\"\n\n      min_size = 2\n      max_size = 5\n      # This value is ignored after the initial creation\n      # https://github.com/bryantbiggs/eks-desired-size-hack\n      desired_size = 2\n\n      # This is not required - demonstrates how to pass additional configuration to nodeadm\n      # Ref https://awslabs.github.io/amazon-eks-ami/nodeadm/doc/api/\n      cloudinit_pre_nodeadm = [\n        {\n          content_type = \"application/node.eks.aws\"\n          content      = <<-EOT\n            ---\n            apiVersion: node.eks.aws/v1alpha1\n            kind: NodeConfig\n            spec:\n              kubelet:\n                config:\n                  shutdownGracePeriod: 30s\n          EOT\n        }\n      ]\n    }\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/self-managed-node-group/eks-bottlerocket.tf"}, "region": {"startLine": 1, "endLine": 56, "snippet": {"text": "module \"eks_bottlerocket\" {\n  source  = \"terraform-aws-modules/eks/aws\"\n  version = \"~> 21.0\"\n\n  name               = \"${local.name}-bottlerocket\"\n  kubernetes_version = \"1.33\"\n\n  # EKS Addons\n  addons = {\n    coredns = {}\n    eks-pod-identity-agent = {\n      before_compute = true\n    }\n    kube-proxy = {}\n    vpc-cni = {\n      before_compute = true\n    }\n  }\n\n  vpc_id     = module.vpc.vpc_id\n  subnet_ids = module.vpc.private_subnets\n\n  self_managed_node_groups = {\n    example = {\n      ami_type      = \"BOTTLEROCKET_x86_64\"\n      instance_type = \"m6i.large\"\n\n      min_size = 2\n      max_size = 5\n      # This value is ignored after the initial creation\n      # https://github.com/bryantbiggs/eks-desired-size-hack\n      desired_size = 2\n\n      # This is not required - demonstrates how to pass additional configuration\n      # Ref https://bottlerocket.dev/en/os/1.19.x/api/settings/\n      bootstrap_extra_args = <<-EOT\n        # The admin host container provides SSH access and runs with \"superpowers\".\n        # It is disabled by default, but can be disabled explicitly.\n        [settings.host-containers.admin]\n        enabled = false\n\n        # The control host container provides out-of-band access via SSM.\n        # It is enabled by default, and can be disabled if you do not expect to use SSM.\n        # This could leave you with no way to access the API and change settings on an existing node!\n        [settings.host-containers.control]\n        enabled = true\n\n        # extra args added\n        [settings.kernel]\n        lockdown = \"integrity\"\n      EOT\n    }\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/self-managed-node-group/main.tf"}, "region": {"startLine": 31, "endLine": 55, "snippet": {"text": "module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 6.0\"\n\n  name = local.name\n  cidr = local.vpc_cidr\n\n  azs             = local.azs\n  private_subnets = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 4, k)]\n  public_subnets  = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 48)]\n  intra_subnets   = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 52)]\n\n  enable_nat_gateway = true\n  single_nat_gateway = true\n\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = 1\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = 1\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 331, "endLine": 365, "snippet": {"text": "module \"kms\" {\n  source  = \"terraform-aws-modules/kms/aws\"\n  version = \"4.0.0\" # Note - be mindful of Terraform/provider version compatibility between modules\n\n  create = local.create && var.create_kms_key && local.enable_encryption_config # not valid on Outposts\n\n  region = var.region\n\n  description             = coalesce(var.kms_key_description, \"${var.name} cluster encryption key\")\n  key_usage               = \"ENCRYPT_DECRYPT\"\n  deletion_window_in_days = var.kms_key_deletion_window_in_days\n  enable_key_rotation     = var.enable_kms_key_rotation\n  rotation_period_in_days = var.kms_key_rotation_period_in_days\n\n  # Policy\n  enable_default_policy     = var.kms_key_enable_default_policy\n  key_owners                = var.kms_key_owners\n  key_administrators        = coalescelist(var.kms_key_administrators, [try(data.aws_iam_session_context.current[0].issuer_arn, \"\")])\n  key_users                 = concat([local.role_arn], var.kms_key_users)\n  key_service_users         = var.kms_key_service_users\n  source_policy_documents   = var.kms_key_source_policy_documents\n  override_policy_documents = var.kms_key_override_policy_documents\n\n  # Aliases\n  aliases = var.kms_key_aliases\n  computed_aliases = {\n    # Computed since users can pass in computed values for cluster name such as random provider resources\n    cluster = { name = \"eks/${var.name}\" }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_37", "ruleIndex": 6, "level": "error", "attachments": [], "message": {"text": "Ensure Amazon EKS control plane logging is enabled for all log types"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 36, "endLine": 206, "snippet": {"text": "resource \"aws_eks_cluster\" \"this\" {\n  count = local.create ? 1 : 0\n\n  region = var.region\n\n  name                          = var.name\n  role_arn                      = local.role_arn\n  version                       = var.kubernetes_version\n  enabled_cluster_log_types     = var.enabled_log_types\n  deletion_protection           = var.deletion_protection\n  bootstrap_self_managed_addons = false\n  force_update_version          = var.force_update_version\n\n  access_config {\n    authentication_mode = var.authentication_mode\n\n    # See access entries below - this is a one time operation from the EKS API.\n    # Instead, we are hardcoding this to false and if users wish to achieve this\n    # same functionality, we will do that through an access entry which can be\n    # enabled or disabled at any time of their choosing using the variable\n    # var.enable_cluster_creator_admin_permissions\n    bootstrap_cluster_creator_admin_permissions = false\n  }\n\n  dynamic \"compute_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      enabled       = compute_config.value.enabled\n      node_pools    = compute_config.value.node_pools\n      node_role_arn = compute_config.value.node_pools != null ? try(aws_iam_role.eks_auto[0].arn, compute_config.value.node_role_arn) : null\n    }\n  }\n\n  vpc_config {\n    security_group_ids      = compact(distinct(concat(var.additional_security_group_ids, [local.security_group_id])))\n    subnet_ids              = coalescelist(var.control_plane_subnet_ids, var.subnet_ids)\n    endpoint_private_access = var.endpoint_private_access\n    endpoint_public_access  = var.endpoint_public_access\n    public_access_cidrs     = var.endpoint_public_access_cidrs\n  }\n\n  dynamic \"kubernetes_network_config\" {\n    # Not valid on Outposts\n    for_each = local.create_outposts_local_cluster ? [] : [1]\n\n    content {\n      dynamic \"elastic_load_balancing\" {\n        for_each = var.compute_config != null ? [var.compute_config] : []\n\n        content {\n          enabled = elastic_load_balancing.value.enabled\n        }\n      }\n\n      ip_family         = var.ip_family\n      service_ipv4_cidr = var.service_ipv4_cidr\n      service_ipv6_cidr = var.service_ipv6_cidr\n    }\n  }\n\n  dynamic \"outpost_config\" {\n    for_each = local.create_outposts_local_cluster ? [var.outpost_config] : []\n\n    content {\n      control_plane_instance_type = outpost_config.value.control_plane_instance_type\n\n      dynamic \"control_plane_placement\" {\n        for_each = outpost_config.value.control_plane_placement != null ? [outpost_config.value.control_plane_placement] : []\n\n        content {\n          group_name = control_plane_placement.value.group_name\n        }\n      }\n\n      outpost_arns = outpost_config.value.outpost_arns\n    }\n  }\n\n  dynamic \"encryption_config\" {\n    # Not available on Outposts\n    for_each = local.enable_encryption_config ? [var.encryption_config] : []\n\n    content {\n      provider {\n        key_arn = var.create_kms_key ? module.kms.key_arn : encryption_config.value.provider_key_arn\n      }\n      resources = encryption_config.value.resources\n    }\n  }\n\n  dynamic \"remote_network_config\" {\n    # Not valid on Outposts\n    for_each = var.remote_network_config != null && !local.create_outposts_local_cluster ? [var.remote_network_config] : []\n\n    content {\n      dynamic \"remote_node_networks\" {\n        for_each = [remote_network_config.value.remote_node_networks]\n\n        content {\n          cidrs = remote_node_networks.value.cidrs\n        }\n      }\n\n      dynamic \"remote_pod_networks\" {\n        for_each = remote_network_config.value.remote_pod_networks != null ? [remote_network_config.value.remote_pod_networks] : []\n\n        content {\n          cidrs = remote_pod_networks.value.cidrs\n        }\n      }\n    }\n  }\n\n  dynamic \"storage_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      block_storage {\n        enabled = storage_config.value.enabled\n      }\n    }\n  }\n\n  dynamic \"upgrade_policy\" {\n    for_each = var.upgrade_policy != null ? [var.upgrade_policy] : []\n\n    content {\n      support_type = upgrade_policy.value.support_type\n    }\n  }\n\n  dynamic \"zonal_shift_config\" {\n    for_each = var.zonal_shift_config != null ? [var.zonal_shift_config] : []\n\n    content {\n      enabled = zonal_shift_config.value.enabled\n    }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n    var.cluster_tags,\n  )\n\n  dynamic \"timeouts\" {\n    for_each = var.timeouts != null ? [var.timeouts] : []\n\n    content {\n      create = var.timeouts.create\n      update = var.timeouts.update\n      delete = var.timeouts.delete\n    }\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_security_group_rule.cluster,\n    aws_security_group_rule.node,\n    aws_cloudwatch_log_group.this,\n    aws_iam_policy.cni_ipv6_policy,\n  ]\n\n  lifecycle {\n    ignore_changes = [\n      access_config[0].bootstrap_cluster_creator_admin_permissions,\n      bootstrap_self_managed_addons,\n    ]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_58", "ruleIndex": 7, "level": "error", "attachments": [], "message": {"text": "Ensure EKS Cluster has Secrets Encryption Enabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 36, "endLine": 206, "snippet": {"text": "resource \"aws_eks_cluster\" \"this\" {\n  count = local.create ? 1 : 0\n\n  region = var.region\n\n  name                          = var.name\n  role_arn                      = local.role_arn\n  version                       = var.kubernetes_version\n  enabled_cluster_log_types     = var.enabled_log_types\n  deletion_protection           = var.deletion_protection\n  bootstrap_self_managed_addons = false\n  force_update_version          = var.force_update_version\n\n  access_config {\n    authentication_mode = var.authentication_mode\n\n    # See access entries below - this is a one time operation from the EKS API.\n    # Instead, we are hardcoding this to false and if users wish to achieve this\n    # same functionality, we will do that through an access entry which can be\n    # enabled or disabled at any time of their choosing using the variable\n    # var.enable_cluster_creator_admin_permissions\n    bootstrap_cluster_creator_admin_permissions = false\n  }\n\n  dynamic \"compute_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      enabled       = compute_config.value.enabled\n      node_pools    = compute_config.value.node_pools\n      node_role_arn = compute_config.value.node_pools != null ? try(aws_iam_role.eks_auto[0].arn, compute_config.value.node_role_arn) : null\n    }\n  }\n\n  vpc_config {\n    security_group_ids      = compact(distinct(concat(var.additional_security_group_ids, [local.security_group_id])))\n    subnet_ids              = coalescelist(var.control_plane_subnet_ids, var.subnet_ids)\n    endpoint_private_access = var.endpoint_private_access\n    endpoint_public_access  = var.endpoint_public_access\n    public_access_cidrs     = var.endpoint_public_access_cidrs\n  }\n\n  dynamic \"kubernetes_network_config\" {\n    # Not valid on Outposts\n    for_each = local.create_outposts_local_cluster ? [] : [1]\n\n    content {\n      dynamic \"elastic_load_balancing\" {\n        for_each = var.compute_config != null ? [var.compute_config] : []\n\n        content {\n          enabled = elastic_load_balancing.value.enabled\n        }\n      }\n\n      ip_family         = var.ip_family\n      service_ipv4_cidr = var.service_ipv4_cidr\n      service_ipv6_cidr = var.service_ipv6_cidr\n    }\n  }\n\n  dynamic \"outpost_config\" {\n    for_each = local.create_outposts_local_cluster ? [var.outpost_config] : []\n\n    content {\n      control_plane_instance_type = outpost_config.value.control_plane_instance_type\n\n      dynamic \"control_plane_placement\" {\n        for_each = outpost_config.value.control_plane_placement != null ? [outpost_config.value.control_plane_placement] : []\n\n        content {\n          group_name = control_plane_placement.value.group_name\n        }\n      }\n\n      outpost_arns = outpost_config.value.outpost_arns\n    }\n  }\n\n  dynamic \"encryption_config\" {\n    # Not available on Outposts\n    for_each = local.enable_encryption_config ? [var.encryption_config] : []\n\n    content {\n      provider {\n        key_arn = var.create_kms_key ? module.kms.key_arn : encryption_config.value.provider_key_arn\n      }\n      resources = encryption_config.value.resources\n    }\n  }\n\n  dynamic \"remote_network_config\" {\n    # Not valid on Outposts\n    for_each = var.remote_network_config != null && !local.create_outposts_local_cluster ? [var.remote_network_config] : []\n\n    content {\n      dynamic \"remote_node_networks\" {\n        for_each = [remote_network_config.value.remote_node_networks]\n\n        content {\n          cidrs = remote_node_networks.value.cidrs\n        }\n      }\n\n      dynamic \"remote_pod_networks\" {\n        for_each = remote_network_config.value.remote_pod_networks != null ? [remote_network_config.value.remote_pod_networks] : []\n\n        content {\n          cidrs = remote_pod_networks.value.cidrs\n        }\n      }\n    }\n  }\n\n  dynamic \"storage_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      block_storage {\n        enabled = storage_config.value.enabled\n      }\n    }\n  }\n\n  dynamic \"upgrade_policy\" {\n    for_each = var.upgrade_policy != null ? [var.upgrade_policy] : []\n\n    content {\n      support_type = upgrade_policy.value.support_type\n    }\n  }\n\n  dynamic \"zonal_shift_config\" {\n    for_each = var.zonal_shift_config != null ? [var.zonal_shift_config] : []\n\n    content {\n      enabled = zonal_shift_config.value.enabled\n    }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n    var.cluster_tags,\n  )\n\n  dynamic \"timeouts\" {\n    for_each = var.timeouts != null ? [var.timeouts] : []\n\n    content {\n      create = var.timeouts.create\n      update = var.timeouts.update\n      delete = var.timeouts.delete\n    }\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_security_group_rule.cluster,\n    aws_security_group_rule.node,\n    aws_cloudwatch_log_group.this,\n    aws_iam_policy.cni_ipv6_policy,\n  ]\n\n  lifecycle {\n    ignore_changes = [\n      access_config[0].bootstrap_cluster_creator_admin_permissions,\n      bootstrap_self_managed_addons,\n    ]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_338", "ruleIndex": 8, "level": "error", "attachments": [], "message": {"text": "Ensure CloudWatch log groups retains logs for at least 1 year"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 223, "endLine": 238, "snippet": {"text": "resource \"aws_cloudwatch_log_group\" \"this\" {\n  count = local.create && var.create_cloudwatch_log_group ? 1 : 0\n\n  region = var.region\n\n  name              = \"/aws/eks/${var.name}/cluster\"\n  retention_in_days = var.cloudwatch_log_group_retention_in_days\n  kms_key_id        = var.cloudwatch_log_group_kms_key_id\n  log_group_class   = var.cloudwatch_log_group_class\n\n  tags = merge(\n    var.tags,\n    var.cloudwatch_log_group_tags,\n    { Name = \"/aws/eks/${var.name}/cluster\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 331, "endLine": 365, "snippet": {"text": "module \"kms\" {\n  source  = \"terraform-aws-modules/kms/aws\"\n  version = \"4.0.0\" # Note - be mindful of Terraform/provider version compatibility between modules\n\n  create = local.create && var.create_kms_key && local.enable_encryption_config # not valid on Outposts\n\n  region = var.region\n\n  description             = coalesce(var.kms_key_description, \"${var.name} cluster encryption key\")\n  key_usage               = \"ENCRYPT_DECRYPT\"\n  deletion_window_in_days = var.kms_key_deletion_window_in_days\n  enable_key_rotation     = var.enable_kms_key_rotation\n  rotation_period_in_days = var.kms_key_rotation_period_in_days\n\n  # Policy\n  enable_default_policy     = var.kms_key_enable_default_policy\n  key_owners                = var.kms_key_owners\n  key_administrators        = coalescelist(var.kms_key_administrators, [try(data.aws_iam_session_context.current[0].issuer_arn, \"\")])\n  key_users                 = concat([local.role_arn], var.kms_key_users)\n  key_service_users         = var.kms_key_service_users\n  source_policy_documents   = var.kms_key_source_policy_documents\n  override_policy_documents = var.kms_key_override_policy_documents\n\n  # Aliases\n  aliases = var.kms_key_aliases\n  computed_aliases = {\n    # Computed since users can pass in computed values for cluster name such as random provider resources\n    cluster = { name = \"eks/${var.name}\" }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_37", "ruleIndex": 6, "level": "error", "attachments": [], "message": {"text": "Ensure Amazon EKS control plane logging is enabled for all log types"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 36, "endLine": 206, "snippet": {"text": "resource \"aws_eks_cluster\" \"this\" {\n  count = local.create ? 1 : 0\n\n  region = var.region\n\n  name                          = var.name\n  role_arn                      = local.role_arn\n  version                       = var.kubernetes_version\n  enabled_cluster_log_types     = var.enabled_log_types\n  deletion_protection           = var.deletion_protection\n  bootstrap_self_managed_addons = false\n  force_update_version          = var.force_update_version\n\n  access_config {\n    authentication_mode = var.authentication_mode\n\n    # See access entries below - this is a one time operation from the EKS API.\n    # Instead, we are hardcoding this to false and if users wish to achieve this\n    # same functionality, we will do that through an access entry which can be\n    # enabled or disabled at any time of their choosing using the variable\n    # var.enable_cluster_creator_admin_permissions\n    bootstrap_cluster_creator_admin_permissions = false\n  }\n\n  dynamic \"compute_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      enabled       = compute_config.value.enabled\n      node_pools    = compute_config.value.node_pools\n      node_role_arn = compute_config.value.node_pools != null ? try(aws_iam_role.eks_auto[0].arn, compute_config.value.node_role_arn) : null\n    }\n  }\n\n  vpc_config {\n    security_group_ids      = compact(distinct(concat(var.additional_security_group_ids, [local.security_group_id])))\n    subnet_ids              = coalescelist(var.control_plane_subnet_ids, var.subnet_ids)\n    endpoint_private_access = var.endpoint_private_access\n    endpoint_public_access  = var.endpoint_public_access\n    public_access_cidrs     = var.endpoint_public_access_cidrs\n  }\n\n  dynamic \"kubernetes_network_config\" {\n    # Not valid on Outposts\n    for_each = local.create_outposts_local_cluster ? [] : [1]\n\n    content {\n      dynamic \"elastic_load_balancing\" {\n        for_each = var.compute_config != null ? [var.compute_config] : []\n\n        content {\n          enabled = elastic_load_balancing.value.enabled\n        }\n      }\n\n      ip_family         = var.ip_family\n      service_ipv4_cidr = var.service_ipv4_cidr\n      service_ipv6_cidr = var.service_ipv6_cidr\n    }\n  }\n\n  dynamic \"outpost_config\" {\n    for_each = local.create_outposts_local_cluster ? [var.outpost_config] : []\n\n    content {\n      control_plane_instance_type = outpost_config.value.control_plane_instance_type\n\n      dynamic \"control_plane_placement\" {\n        for_each = outpost_config.value.control_plane_placement != null ? [outpost_config.value.control_plane_placement] : []\n\n        content {\n          group_name = control_plane_placement.value.group_name\n        }\n      }\n\n      outpost_arns = outpost_config.value.outpost_arns\n    }\n  }\n\n  dynamic \"encryption_config\" {\n    # Not available on Outposts\n    for_each = local.enable_encryption_config ? [var.encryption_config] : []\n\n    content {\n      provider {\n        key_arn = var.create_kms_key ? module.kms.key_arn : encryption_config.value.provider_key_arn\n      }\n      resources = encryption_config.value.resources\n    }\n  }\n\n  dynamic \"remote_network_config\" {\n    # Not valid on Outposts\n    for_each = var.remote_network_config != null && !local.create_outposts_local_cluster ? [var.remote_network_config] : []\n\n    content {\n      dynamic \"remote_node_networks\" {\n        for_each = [remote_network_config.value.remote_node_networks]\n\n        content {\n          cidrs = remote_node_networks.value.cidrs\n        }\n      }\n\n      dynamic \"remote_pod_networks\" {\n        for_each = remote_network_config.value.remote_pod_networks != null ? [remote_network_config.value.remote_pod_networks] : []\n\n        content {\n          cidrs = remote_pod_networks.value.cidrs\n        }\n      }\n    }\n  }\n\n  dynamic \"storage_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      block_storage {\n        enabled = storage_config.value.enabled\n      }\n    }\n  }\n\n  dynamic \"upgrade_policy\" {\n    for_each = var.upgrade_policy != null ? [var.upgrade_policy] : []\n\n    content {\n      support_type = upgrade_policy.value.support_type\n    }\n  }\n\n  dynamic \"zonal_shift_config\" {\n    for_each = var.zonal_shift_config != null ? [var.zonal_shift_config] : []\n\n    content {\n      enabled = zonal_shift_config.value.enabled\n    }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n    var.cluster_tags,\n  )\n\n  dynamic \"timeouts\" {\n    for_each = var.timeouts != null ? [var.timeouts] : []\n\n    content {\n      create = var.timeouts.create\n      update = var.timeouts.update\n      delete = var.timeouts.delete\n    }\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_security_group_rule.cluster,\n    aws_security_group_rule.node,\n    aws_cloudwatch_log_group.this,\n    aws_iam_policy.cni_ipv6_policy,\n  ]\n\n  lifecycle {\n    ignore_changes = [\n      access_config[0].bootstrap_cluster_creator_admin_permissions,\n      bootstrap_self_managed_addons,\n    ]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_39", "ruleIndex": 9, "level": "error", "attachments": [], "message": {"text": "Ensure Amazon EKS public endpoint disabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 36, "endLine": 206, "snippet": {"text": "resource \"aws_eks_cluster\" \"this\" {\n  count = local.create ? 1 : 0\n\n  region = var.region\n\n  name                          = var.name\n  role_arn                      = local.role_arn\n  version                       = var.kubernetes_version\n  enabled_cluster_log_types     = var.enabled_log_types\n  deletion_protection           = var.deletion_protection\n  bootstrap_self_managed_addons = false\n  force_update_version          = var.force_update_version\n\n  access_config {\n    authentication_mode = var.authentication_mode\n\n    # See access entries below - this is a one time operation from the EKS API.\n    # Instead, we are hardcoding this to false and if users wish to achieve this\n    # same functionality, we will do that through an access entry which can be\n    # enabled or disabled at any time of their choosing using the variable\n    # var.enable_cluster_creator_admin_permissions\n    bootstrap_cluster_creator_admin_permissions = false\n  }\n\n  dynamic \"compute_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      enabled       = compute_config.value.enabled\n      node_pools    = compute_config.value.node_pools\n      node_role_arn = compute_config.value.node_pools != null ? try(aws_iam_role.eks_auto[0].arn, compute_config.value.node_role_arn) : null\n    }\n  }\n\n  vpc_config {\n    security_group_ids      = compact(distinct(concat(var.additional_security_group_ids, [local.security_group_id])))\n    subnet_ids              = coalescelist(var.control_plane_subnet_ids, var.subnet_ids)\n    endpoint_private_access = var.endpoint_private_access\n    endpoint_public_access  = var.endpoint_public_access\n    public_access_cidrs     = var.endpoint_public_access_cidrs\n  }\n\n  dynamic \"kubernetes_network_config\" {\n    # Not valid on Outposts\n    for_each = local.create_outposts_local_cluster ? [] : [1]\n\n    content {\n      dynamic \"elastic_load_balancing\" {\n        for_each = var.compute_config != null ? [var.compute_config] : []\n\n        content {\n          enabled = elastic_load_balancing.value.enabled\n        }\n      }\n\n      ip_family         = var.ip_family\n      service_ipv4_cidr = var.service_ipv4_cidr\n      service_ipv6_cidr = var.service_ipv6_cidr\n    }\n  }\n\n  dynamic \"outpost_config\" {\n    for_each = local.create_outposts_local_cluster ? [var.outpost_config] : []\n\n    content {\n      control_plane_instance_type = outpost_config.value.control_plane_instance_type\n\n      dynamic \"control_plane_placement\" {\n        for_each = outpost_config.value.control_plane_placement != null ? [outpost_config.value.control_plane_placement] : []\n\n        content {\n          group_name = control_plane_placement.value.group_name\n        }\n      }\n\n      outpost_arns = outpost_config.value.outpost_arns\n    }\n  }\n\n  dynamic \"encryption_config\" {\n    # Not available on Outposts\n    for_each = local.enable_encryption_config ? [var.encryption_config] : []\n\n    content {\n      provider {\n        key_arn = var.create_kms_key ? module.kms.key_arn : encryption_config.value.provider_key_arn\n      }\n      resources = encryption_config.value.resources\n    }\n  }\n\n  dynamic \"remote_network_config\" {\n    # Not valid on Outposts\n    for_each = var.remote_network_config != null && !local.create_outposts_local_cluster ? [var.remote_network_config] : []\n\n    content {\n      dynamic \"remote_node_networks\" {\n        for_each = [remote_network_config.value.remote_node_networks]\n\n        content {\n          cidrs = remote_node_networks.value.cidrs\n        }\n      }\n\n      dynamic \"remote_pod_networks\" {\n        for_each = remote_network_config.value.remote_pod_networks != null ? [remote_network_config.value.remote_pod_networks] : []\n\n        content {\n          cidrs = remote_pod_networks.value.cidrs\n        }\n      }\n    }\n  }\n\n  dynamic \"storage_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      block_storage {\n        enabled = storage_config.value.enabled\n      }\n    }\n  }\n\n  dynamic \"upgrade_policy\" {\n    for_each = var.upgrade_policy != null ? [var.upgrade_policy] : []\n\n    content {\n      support_type = upgrade_policy.value.support_type\n    }\n  }\n\n  dynamic \"zonal_shift_config\" {\n    for_each = var.zonal_shift_config != null ? [var.zonal_shift_config] : []\n\n    content {\n      enabled = zonal_shift_config.value.enabled\n    }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n    var.cluster_tags,\n  )\n\n  dynamic \"timeouts\" {\n    for_each = var.timeouts != null ? [var.timeouts] : []\n\n    content {\n      create = var.timeouts.create\n      update = var.timeouts.update\n      delete = var.timeouts.delete\n    }\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_security_group_rule.cluster,\n    aws_security_group_rule.node,\n    aws_cloudwatch_log_group.this,\n    aws_iam_policy.cni_ipv6_policy,\n  ]\n\n  lifecycle {\n    ignore_changes = [\n      access_config[0].bootstrap_cluster_creator_admin_permissions,\n      bootstrap_self_managed_addons,\n    ]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_38", "ruleIndex": 10, "level": "error", "attachments": [], "message": {"text": "Ensure Amazon EKS public endpoint not accessible to 0.0.0.0/0"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 36, "endLine": 206, "snippet": {"text": "resource \"aws_eks_cluster\" \"this\" {\n  count = local.create ? 1 : 0\n\n  region = var.region\n\n  name                          = var.name\n  role_arn                      = local.role_arn\n  version                       = var.kubernetes_version\n  enabled_cluster_log_types     = var.enabled_log_types\n  deletion_protection           = var.deletion_protection\n  bootstrap_self_managed_addons = false\n  force_update_version          = var.force_update_version\n\n  access_config {\n    authentication_mode = var.authentication_mode\n\n    # See access entries below - this is a one time operation from the EKS API.\n    # Instead, we are hardcoding this to false and if users wish to achieve this\n    # same functionality, we will do that through an access entry which can be\n    # enabled or disabled at any time of their choosing using the variable\n    # var.enable_cluster_creator_admin_permissions\n    bootstrap_cluster_creator_admin_permissions = false\n  }\n\n  dynamic \"compute_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      enabled       = compute_config.value.enabled\n      node_pools    = compute_config.value.node_pools\n      node_role_arn = compute_config.value.node_pools != null ? try(aws_iam_role.eks_auto[0].arn, compute_config.value.node_role_arn) : null\n    }\n  }\n\n  vpc_config {\n    security_group_ids      = compact(distinct(concat(var.additional_security_group_ids, [local.security_group_id])))\n    subnet_ids              = coalescelist(var.control_plane_subnet_ids, var.subnet_ids)\n    endpoint_private_access = var.endpoint_private_access\n    endpoint_public_access  = var.endpoint_public_access\n    public_access_cidrs     = var.endpoint_public_access_cidrs\n  }\n\n  dynamic \"kubernetes_network_config\" {\n    # Not valid on Outposts\n    for_each = local.create_outposts_local_cluster ? [] : [1]\n\n    content {\n      dynamic \"elastic_load_balancing\" {\n        for_each = var.compute_config != null ? [var.compute_config] : []\n\n        content {\n          enabled = elastic_load_balancing.value.enabled\n        }\n      }\n\n      ip_family         = var.ip_family\n      service_ipv4_cidr = var.service_ipv4_cidr\n      service_ipv6_cidr = var.service_ipv6_cidr\n    }\n  }\n\n  dynamic \"outpost_config\" {\n    for_each = local.create_outposts_local_cluster ? [var.outpost_config] : []\n\n    content {\n      control_plane_instance_type = outpost_config.value.control_plane_instance_type\n\n      dynamic \"control_plane_placement\" {\n        for_each = outpost_config.value.control_plane_placement != null ? [outpost_config.value.control_plane_placement] : []\n\n        content {\n          group_name = control_plane_placement.value.group_name\n        }\n      }\n\n      outpost_arns = outpost_config.value.outpost_arns\n    }\n  }\n\n  dynamic \"encryption_config\" {\n    # Not available on Outposts\n    for_each = local.enable_encryption_config ? [var.encryption_config] : []\n\n    content {\n      provider {\n        key_arn = var.create_kms_key ? module.kms.key_arn : encryption_config.value.provider_key_arn\n      }\n      resources = encryption_config.value.resources\n    }\n  }\n\n  dynamic \"remote_network_config\" {\n    # Not valid on Outposts\n    for_each = var.remote_network_config != null && !local.create_outposts_local_cluster ? [var.remote_network_config] : []\n\n    content {\n      dynamic \"remote_node_networks\" {\n        for_each = [remote_network_config.value.remote_node_networks]\n\n        content {\n          cidrs = remote_node_networks.value.cidrs\n        }\n      }\n\n      dynamic \"remote_pod_networks\" {\n        for_each = remote_network_config.value.remote_pod_networks != null ? [remote_network_config.value.remote_pod_networks] : []\n\n        content {\n          cidrs = remote_pod_networks.value.cidrs\n        }\n      }\n    }\n  }\n\n  dynamic \"storage_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      block_storage {\n        enabled = storage_config.value.enabled\n      }\n    }\n  }\n\n  dynamic \"upgrade_policy\" {\n    for_each = var.upgrade_policy != null ? [var.upgrade_policy] : []\n\n    content {\n      support_type = upgrade_policy.value.support_type\n    }\n  }\n\n  dynamic \"zonal_shift_config\" {\n    for_each = var.zonal_shift_config != null ? [var.zonal_shift_config] : []\n\n    content {\n      enabled = zonal_shift_config.value.enabled\n    }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n    var.cluster_tags,\n  )\n\n  dynamic \"timeouts\" {\n    for_each = var.timeouts != null ? [var.timeouts] : []\n\n    content {\n      create = var.timeouts.create\n      update = var.timeouts.update\n      delete = var.timeouts.delete\n    }\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_security_group_rule.cluster,\n    aws_security_group_rule.node,\n    aws_cloudwatch_log_group.this,\n    aws_iam_policy.cni_ipv6_policy,\n  ]\n\n  lifecycle {\n    ignore_changes = [\n      access_config[0].bootstrap_cluster_creator_admin_permissions,\n      bootstrap_self_managed_addons,\n    ]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_58", "ruleIndex": 7, "level": "error", "attachments": [], "message": {"text": "Ensure EKS Cluster has Secrets Encryption Enabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 36, "endLine": 206, "snippet": {"text": "resource \"aws_eks_cluster\" \"this\" {\n  count = local.create ? 1 : 0\n\n  region = var.region\n\n  name                          = var.name\n  role_arn                      = local.role_arn\n  version                       = var.kubernetes_version\n  enabled_cluster_log_types     = var.enabled_log_types\n  deletion_protection           = var.deletion_protection\n  bootstrap_self_managed_addons = false\n  force_update_version          = var.force_update_version\n\n  access_config {\n    authentication_mode = var.authentication_mode\n\n    # See access entries below - this is a one time operation from the EKS API.\n    # Instead, we are hardcoding this to false and if users wish to achieve this\n    # same functionality, we will do that through an access entry which can be\n    # enabled or disabled at any time of their choosing using the variable\n    # var.enable_cluster_creator_admin_permissions\n    bootstrap_cluster_creator_admin_permissions = false\n  }\n\n  dynamic \"compute_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      enabled       = compute_config.value.enabled\n      node_pools    = compute_config.value.node_pools\n      node_role_arn = compute_config.value.node_pools != null ? try(aws_iam_role.eks_auto[0].arn, compute_config.value.node_role_arn) : null\n    }\n  }\n\n  vpc_config {\n    security_group_ids      = compact(distinct(concat(var.additional_security_group_ids, [local.security_group_id])))\n    subnet_ids              = coalescelist(var.control_plane_subnet_ids, var.subnet_ids)\n    endpoint_private_access = var.endpoint_private_access\n    endpoint_public_access  = var.endpoint_public_access\n    public_access_cidrs     = var.endpoint_public_access_cidrs\n  }\n\n  dynamic \"kubernetes_network_config\" {\n    # Not valid on Outposts\n    for_each = local.create_outposts_local_cluster ? [] : [1]\n\n    content {\n      dynamic \"elastic_load_balancing\" {\n        for_each = var.compute_config != null ? [var.compute_config] : []\n\n        content {\n          enabled = elastic_load_balancing.value.enabled\n        }\n      }\n\n      ip_family         = var.ip_family\n      service_ipv4_cidr = var.service_ipv4_cidr\n      service_ipv6_cidr = var.service_ipv6_cidr\n    }\n  }\n\n  dynamic \"outpost_config\" {\n    for_each = local.create_outposts_local_cluster ? [var.outpost_config] : []\n\n    content {\n      control_plane_instance_type = outpost_config.value.control_plane_instance_type\n\n      dynamic \"control_plane_placement\" {\n        for_each = outpost_config.value.control_plane_placement != null ? [outpost_config.value.control_plane_placement] : []\n\n        content {\n          group_name = control_plane_placement.value.group_name\n        }\n      }\n\n      outpost_arns = outpost_config.value.outpost_arns\n    }\n  }\n\n  dynamic \"encryption_config\" {\n    # Not available on Outposts\n    for_each = local.enable_encryption_config ? [var.encryption_config] : []\n\n    content {\n      provider {\n        key_arn = var.create_kms_key ? module.kms.key_arn : encryption_config.value.provider_key_arn\n      }\n      resources = encryption_config.value.resources\n    }\n  }\n\n  dynamic \"remote_network_config\" {\n    # Not valid on Outposts\n    for_each = var.remote_network_config != null && !local.create_outposts_local_cluster ? [var.remote_network_config] : []\n\n    content {\n      dynamic \"remote_node_networks\" {\n        for_each = [remote_network_config.value.remote_node_networks]\n\n        content {\n          cidrs = remote_node_networks.value.cidrs\n        }\n      }\n\n      dynamic \"remote_pod_networks\" {\n        for_each = remote_network_config.value.remote_pod_networks != null ? [remote_network_config.value.remote_pod_networks] : []\n\n        content {\n          cidrs = remote_pod_networks.value.cidrs\n        }\n      }\n    }\n  }\n\n  dynamic \"storage_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      block_storage {\n        enabled = storage_config.value.enabled\n      }\n    }\n  }\n\n  dynamic \"upgrade_policy\" {\n    for_each = var.upgrade_policy != null ? [var.upgrade_policy] : []\n\n    content {\n      support_type = upgrade_policy.value.support_type\n    }\n  }\n\n  dynamic \"zonal_shift_config\" {\n    for_each = var.zonal_shift_config != null ? [var.zonal_shift_config] : []\n\n    content {\n      enabled = zonal_shift_config.value.enabled\n    }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n    var.cluster_tags,\n  )\n\n  dynamic \"timeouts\" {\n    for_each = var.timeouts != null ? [var.timeouts] : []\n\n    content {\n      create = var.timeouts.create\n      update = var.timeouts.update\n      delete = var.timeouts.delete\n    }\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_security_group_rule.cluster,\n    aws_security_group_rule.node,\n    aws_cloudwatch_log_group.this,\n    aws_iam_policy.cni_ipv6_policy,\n  ]\n\n  lifecycle {\n    ignore_changes = [\n      access_config[0].bootstrap_cluster_creator_admin_permissions,\n      bootstrap_self_managed_addons,\n    ]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_338", "ruleIndex": 8, "level": "error", "attachments": [], "message": {"text": "Ensure CloudWatch log groups retains logs for at least 1 year"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 223, "endLine": 238, "snippet": {"text": "resource \"aws_cloudwatch_log_group\" \"this\" {\n  count = local.create && var.create_cloudwatch_log_group ? 1 : 0\n\n  region = var.region\n\n  name              = \"/aws/eks/${var.name}/cluster\"\n  retention_in_days = var.cloudwatch_log_group_retention_in_days\n  kms_key_id        = var.cloudwatch_log_group_kms_key_id\n  log_group_class   = var.cloudwatch_log_group_class\n\n  tags = merge(\n    var.tags,\n    var.cloudwatch_log_group_tags,\n    { Name = \"/aws/eks/${var.name}/cluster\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 331, "endLine": 365, "snippet": {"text": "module \"kms\" {\n  source  = \"terraform-aws-modules/kms/aws\"\n  version = \"4.0.0\" # Note - be mindful of Terraform/provider version compatibility between modules\n\n  create = local.create && var.create_kms_key && local.enable_encryption_config # not valid on Outposts\n\n  region = var.region\n\n  description             = coalesce(var.kms_key_description, \"${var.name} cluster encryption key\")\n  key_usage               = \"ENCRYPT_DECRYPT\"\n  deletion_window_in_days = var.kms_key_deletion_window_in_days\n  enable_key_rotation     = var.enable_kms_key_rotation\n  rotation_period_in_days = var.kms_key_rotation_period_in_days\n\n  # Policy\n  enable_default_policy     = var.kms_key_enable_default_policy\n  key_owners                = var.kms_key_owners\n  key_administrators        = coalescelist(var.kms_key_administrators, [try(data.aws_iam_session_context.current[0].issuer_arn, \"\")])\n  key_users                 = concat([local.role_arn], var.kms_key_users)\n  key_service_users         = var.kms_key_service_users\n  source_policy_documents   = var.kms_key_source_policy_documents\n  override_policy_documents = var.kms_key_override_policy_documents\n\n  # Aliases\n  aliases = var.kms_key_aliases\n  computed_aliases = {\n    # Computed since users can pass in computed values for cluster name such as random provider resources\n    cluster = { name = \"eks/${var.name}\" }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_37", "ruleIndex": 6, "level": "error", "attachments": [], "message": {"text": "Ensure Amazon EKS control plane logging is enabled for all log types"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 36, "endLine": 206, "snippet": {"text": "resource \"aws_eks_cluster\" \"this\" {\n  count = local.create ? 1 : 0\n\n  region = var.region\n\n  name                          = var.name\n  role_arn                      = local.role_arn\n  version                       = var.kubernetes_version\n  enabled_cluster_log_types     = var.enabled_log_types\n  deletion_protection           = var.deletion_protection\n  bootstrap_self_managed_addons = false\n  force_update_version          = var.force_update_version\n\n  access_config {\n    authentication_mode = var.authentication_mode\n\n    # See access entries below - this is a one time operation from the EKS API.\n    # Instead, we are hardcoding this to false and if users wish to achieve this\n    # same functionality, we will do that through an access entry which can be\n    # enabled or disabled at any time of their choosing using the variable\n    # var.enable_cluster_creator_admin_permissions\n    bootstrap_cluster_creator_admin_permissions = false\n  }\n\n  dynamic \"compute_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      enabled       = compute_config.value.enabled\n      node_pools    = compute_config.value.node_pools\n      node_role_arn = compute_config.value.node_pools != null ? try(aws_iam_role.eks_auto[0].arn, compute_config.value.node_role_arn) : null\n    }\n  }\n\n  vpc_config {\n    security_group_ids      = compact(distinct(concat(var.additional_security_group_ids, [local.security_group_id])))\n    subnet_ids              = coalescelist(var.control_plane_subnet_ids, var.subnet_ids)\n    endpoint_private_access = var.endpoint_private_access\n    endpoint_public_access  = var.endpoint_public_access\n    public_access_cidrs     = var.endpoint_public_access_cidrs\n  }\n\n  dynamic \"kubernetes_network_config\" {\n    # Not valid on Outposts\n    for_each = local.create_outposts_local_cluster ? [] : [1]\n\n    content {\n      dynamic \"elastic_load_balancing\" {\n        for_each = var.compute_config != null ? [var.compute_config] : []\n\n        content {\n          enabled = elastic_load_balancing.value.enabled\n        }\n      }\n\n      ip_family         = var.ip_family\n      service_ipv4_cidr = var.service_ipv4_cidr\n      service_ipv6_cidr = var.service_ipv6_cidr\n    }\n  }\n\n  dynamic \"outpost_config\" {\n    for_each = local.create_outposts_local_cluster ? [var.outpost_config] : []\n\n    content {\n      control_plane_instance_type = outpost_config.value.control_plane_instance_type\n\n      dynamic \"control_plane_placement\" {\n        for_each = outpost_config.value.control_plane_placement != null ? [outpost_config.value.control_plane_placement] : []\n\n        content {\n          group_name = control_plane_placement.value.group_name\n        }\n      }\n\n      outpost_arns = outpost_config.value.outpost_arns\n    }\n  }\n\n  dynamic \"encryption_config\" {\n    # Not available on Outposts\n    for_each = local.enable_encryption_config ? [var.encryption_config] : []\n\n    content {\n      provider {\n        key_arn = var.create_kms_key ? module.kms.key_arn : encryption_config.value.provider_key_arn\n      }\n      resources = encryption_config.value.resources\n    }\n  }\n\n  dynamic \"remote_network_config\" {\n    # Not valid on Outposts\n    for_each = var.remote_network_config != null && !local.create_outposts_local_cluster ? [var.remote_network_config] : []\n\n    content {\n      dynamic \"remote_node_networks\" {\n        for_each = [remote_network_config.value.remote_node_networks]\n\n        content {\n          cidrs = remote_node_networks.value.cidrs\n        }\n      }\n\n      dynamic \"remote_pod_networks\" {\n        for_each = remote_network_config.value.remote_pod_networks != null ? [remote_network_config.value.remote_pod_networks] : []\n\n        content {\n          cidrs = remote_pod_networks.value.cidrs\n        }\n      }\n    }\n  }\n\n  dynamic \"storage_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      block_storage {\n        enabled = storage_config.value.enabled\n      }\n    }\n  }\n\n  dynamic \"upgrade_policy\" {\n    for_each = var.upgrade_policy != null ? [var.upgrade_policy] : []\n\n    content {\n      support_type = upgrade_policy.value.support_type\n    }\n  }\n\n  dynamic \"zonal_shift_config\" {\n    for_each = var.zonal_shift_config != null ? [var.zonal_shift_config] : []\n\n    content {\n      enabled = zonal_shift_config.value.enabled\n    }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n    var.cluster_tags,\n  )\n\n  dynamic \"timeouts\" {\n    for_each = var.timeouts != null ? [var.timeouts] : []\n\n    content {\n      create = var.timeouts.create\n      update = var.timeouts.update\n      delete = var.timeouts.delete\n    }\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_security_group_rule.cluster,\n    aws_security_group_rule.node,\n    aws_cloudwatch_log_group.this,\n    aws_iam_policy.cni_ipv6_policy,\n  ]\n\n  lifecycle {\n    ignore_changes = [\n      access_config[0].bootstrap_cluster_creator_admin_permissions,\n      bootstrap_self_managed_addons,\n    ]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_39", "ruleIndex": 9, "level": "error", "attachments": [], "message": {"text": "Ensure Amazon EKS public endpoint disabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 36, "endLine": 206, "snippet": {"text": "resource \"aws_eks_cluster\" \"this\" {\n  count = local.create ? 1 : 0\n\n  region = var.region\n\n  name                          = var.name\n  role_arn                      = local.role_arn\n  version                       = var.kubernetes_version\n  enabled_cluster_log_types     = var.enabled_log_types\n  deletion_protection           = var.deletion_protection\n  bootstrap_self_managed_addons = false\n  force_update_version          = var.force_update_version\n\n  access_config {\n    authentication_mode = var.authentication_mode\n\n    # See access entries below - this is a one time operation from the EKS API.\n    # Instead, we are hardcoding this to false and if users wish to achieve this\n    # same functionality, we will do that through an access entry which can be\n    # enabled or disabled at any time of their choosing using the variable\n    # var.enable_cluster_creator_admin_permissions\n    bootstrap_cluster_creator_admin_permissions = false\n  }\n\n  dynamic \"compute_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      enabled       = compute_config.value.enabled\n      node_pools    = compute_config.value.node_pools\n      node_role_arn = compute_config.value.node_pools != null ? try(aws_iam_role.eks_auto[0].arn, compute_config.value.node_role_arn) : null\n    }\n  }\n\n  vpc_config {\n    security_group_ids      = compact(distinct(concat(var.additional_security_group_ids, [local.security_group_id])))\n    subnet_ids              = coalescelist(var.control_plane_subnet_ids, var.subnet_ids)\n    endpoint_private_access = var.endpoint_private_access\n    endpoint_public_access  = var.endpoint_public_access\n    public_access_cidrs     = var.endpoint_public_access_cidrs\n  }\n\n  dynamic \"kubernetes_network_config\" {\n    # Not valid on Outposts\n    for_each = local.create_outposts_local_cluster ? [] : [1]\n\n    content {\n      dynamic \"elastic_load_balancing\" {\n        for_each = var.compute_config != null ? [var.compute_config] : []\n\n        content {\n          enabled = elastic_load_balancing.value.enabled\n        }\n      }\n\n      ip_family         = var.ip_family\n      service_ipv4_cidr = var.service_ipv4_cidr\n      service_ipv6_cidr = var.service_ipv6_cidr\n    }\n  }\n\n  dynamic \"outpost_config\" {\n    for_each = local.create_outposts_local_cluster ? [var.outpost_config] : []\n\n    content {\n      control_plane_instance_type = outpost_config.value.control_plane_instance_type\n\n      dynamic \"control_plane_placement\" {\n        for_each = outpost_config.value.control_plane_placement != null ? [outpost_config.value.control_plane_placement] : []\n\n        content {\n          group_name = control_plane_placement.value.group_name\n        }\n      }\n\n      outpost_arns = outpost_config.value.outpost_arns\n    }\n  }\n\n  dynamic \"encryption_config\" {\n    # Not available on Outposts\n    for_each = local.enable_encryption_config ? [var.encryption_config] : []\n\n    content {\n      provider {\n        key_arn = var.create_kms_key ? module.kms.key_arn : encryption_config.value.provider_key_arn\n      }\n      resources = encryption_config.value.resources\n    }\n  }\n\n  dynamic \"remote_network_config\" {\n    # Not valid on Outposts\n    for_each = var.remote_network_config != null && !local.create_outposts_local_cluster ? [var.remote_network_config] : []\n\n    content {\n      dynamic \"remote_node_networks\" {\n        for_each = [remote_network_config.value.remote_node_networks]\n\n        content {\n          cidrs = remote_node_networks.value.cidrs\n        }\n      }\n\n      dynamic \"remote_pod_networks\" {\n        for_each = remote_network_config.value.remote_pod_networks != null ? [remote_network_config.value.remote_pod_networks] : []\n\n        content {\n          cidrs = remote_pod_networks.value.cidrs\n        }\n      }\n    }\n  }\n\n  dynamic \"storage_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      block_storage {\n        enabled = storage_config.value.enabled\n      }\n    }\n  }\n\n  dynamic \"upgrade_policy\" {\n    for_each = var.upgrade_policy != null ? [var.upgrade_policy] : []\n\n    content {\n      support_type = upgrade_policy.value.support_type\n    }\n  }\n\n  dynamic \"zonal_shift_config\" {\n    for_each = var.zonal_shift_config != null ? [var.zonal_shift_config] : []\n\n    content {\n      enabled = zonal_shift_config.value.enabled\n    }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n    var.cluster_tags,\n  )\n\n  dynamic \"timeouts\" {\n    for_each = var.timeouts != null ? [var.timeouts] : []\n\n    content {\n      create = var.timeouts.create\n      update = var.timeouts.update\n      delete = var.timeouts.delete\n    }\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_security_group_rule.cluster,\n    aws_security_group_rule.node,\n    aws_cloudwatch_log_group.this,\n    aws_iam_policy.cni_ipv6_policy,\n  ]\n\n  lifecycle {\n    ignore_changes = [\n      access_config[0].bootstrap_cluster_creator_admin_permissions,\n      bootstrap_self_managed_addons,\n    ]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_38", "ruleIndex": 10, "level": "error", "attachments": [], "message": {"text": "Ensure Amazon EKS public endpoint not accessible to 0.0.0.0/0"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 36, "endLine": 206, "snippet": {"text": "resource \"aws_eks_cluster\" \"this\" {\n  count = local.create ? 1 : 0\n\n  region = var.region\n\n  name                          = var.name\n  role_arn                      = local.role_arn\n  version                       = var.kubernetes_version\n  enabled_cluster_log_types     = var.enabled_log_types\n  deletion_protection           = var.deletion_protection\n  bootstrap_self_managed_addons = false\n  force_update_version          = var.force_update_version\n\n  access_config {\n    authentication_mode = var.authentication_mode\n\n    # See access entries below - this is a one time operation from the EKS API.\n    # Instead, we are hardcoding this to false and if users wish to achieve this\n    # same functionality, we will do that through an access entry which can be\n    # enabled or disabled at any time of their choosing using the variable\n    # var.enable_cluster_creator_admin_permissions\n    bootstrap_cluster_creator_admin_permissions = false\n  }\n\n  dynamic \"compute_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      enabled       = compute_config.value.enabled\n      node_pools    = compute_config.value.node_pools\n      node_role_arn = compute_config.value.node_pools != null ? try(aws_iam_role.eks_auto[0].arn, compute_config.value.node_role_arn) : null\n    }\n  }\n\n  vpc_config {\n    security_group_ids      = compact(distinct(concat(var.additional_security_group_ids, [local.security_group_id])))\n    subnet_ids              = coalescelist(var.control_plane_subnet_ids, var.subnet_ids)\n    endpoint_private_access = var.endpoint_private_access\n    endpoint_public_access  = var.endpoint_public_access\n    public_access_cidrs     = var.endpoint_public_access_cidrs\n  }\n\n  dynamic \"kubernetes_network_config\" {\n    # Not valid on Outposts\n    for_each = local.create_outposts_local_cluster ? [] : [1]\n\n    content {\n      dynamic \"elastic_load_balancing\" {\n        for_each = var.compute_config != null ? [var.compute_config] : []\n\n        content {\n          enabled = elastic_load_balancing.value.enabled\n        }\n      }\n\n      ip_family         = var.ip_family\n      service_ipv4_cidr = var.service_ipv4_cidr\n      service_ipv6_cidr = var.service_ipv6_cidr\n    }\n  }\n\n  dynamic \"outpost_config\" {\n    for_each = local.create_outposts_local_cluster ? [var.outpost_config] : []\n\n    content {\n      control_plane_instance_type = outpost_config.value.control_plane_instance_type\n\n      dynamic \"control_plane_placement\" {\n        for_each = outpost_config.value.control_plane_placement != null ? [outpost_config.value.control_plane_placement] : []\n\n        content {\n          group_name = control_plane_placement.value.group_name\n        }\n      }\n\n      outpost_arns = outpost_config.value.outpost_arns\n    }\n  }\n\n  dynamic \"encryption_config\" {\n    # Not available on Outposts\n    for_each = local.enable_encryption_config ? [var.encryption_config] : []\n\n    content {\n      provider {\n        key_arn = var.create_kms_key ? module.kms.key_arn : encryption_config.value.provider_key_arn\n      }\n      resources = encryption_config.value.resources\n    }\n  }\n\n  dynamic \"remote_network_config\" {\n    # Not valid on Outposts\n    for_each = var.remote_network_config != null && !local.create_outposts_local_cluster ? [var.remote_network_config] : []\n\n    content {\n      dynamic \"remote_node_networks\" {\n        for_each = [remote_network_config.value.remote_node_networks]\n\n        content {\n          cidrs = remote_node_networks.value.cidrs\n        }\n      }\n\n      dynamic \"remote_pod_networks\" {\n        for_each = remote_network_config.value.remote_pod_networks != null ? [remote_network_config.value.remote_pod_networks] : []\n\n        content {\n          cidrs = remote_pod_networks.value.cidrs\n        }\n      }\n    }\n  }\n\n  dynamic \"storage_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      block_storage {\n        enabled = storage_config.value.enabled\n      }\n    }\n  }\n\n  dynamic \"upgrade_policy\" {\n    for_each = var.upgrade_policy != null ? [var.upgrade_policy] : []\n\n    content {\n      support_type = upgrade_policy.value.support_type\n    }\n  }\n\n  dynamic \"zonal_shift_config\" {\n    for_each = var.zonal_shift_config != null ? [var.zonal_shift_config] : []\n\n    content {\n      enabled = zonal_shift_config.value.enabled\n    }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n    var.cluster_tags,\n  )\n\n  dynamic \"timeouts\" {\n    for_each = var.timeouts != null ? [var.timeouts] : []\n\n    content {\n      create = var.timeouts.create\n      update = var.timeouts.update\n      delete = var.timeouts.delete\n    }\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_security_group_rule.cluster,\n    aws_security_group_rule.node,\n    aws_cloudwatch_log_group.this,\n    aws_iam_policy.cni_ipv6_policy,\n  ]\n\n  lifecycle {\n    ignore_changes = [\n      access_config[0].bootstrap_cluster_creator_admin_permissions,\n      bootstrap_self_managed_addons,\n    ]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_58", "ruleIndex": 7, "level": "error", "attachments": [], "message": {"text": "Ensure EKS Cluster has Secrets Encryption Enabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 36, "endLine": 206, "snippet": {"text": "resource \"aws_eks_cluster\" \"this\" {\n  count = local.create ? 1 : 0\n\n  region = var.region\n\n  name                          = var.name\n  role_arn                      = local.role_arn\n  version                       = var.kubernetes_version\n  enabled_cluster_log_types     = var.enabled_log_types\n  deletion_protection           = var.deletion_protection\n  bootstrap_self_managed_addons = false\n  force_update_version          = var.force_update_version\n\n  access_config {\n    authentication_mode = var.authentication_mode\n\n    # See access entries below - this is a one time operation from the EKS API.\n    # Instead, we are hardcoding this to false and if users wish to achieve this\n    # same functionality, we will do that through an access entry which can be\n    # enabled or disabled at any time of their choosing using the variable\n    # var.enable_cluster_creator_admin_permissions\n    bootstrap_cluster_creator_admin_permissions = false\n  }\n\n  dynamic \"compute_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      enabled       = compute_config.value.enabled\n      node_pools    = compute_config.value.node_pools\n      node_role_arn = compute_config.value.node_pools != null ? try(aws_iam_role.eks_auto[0].arn, compute_config.value.node_role_arn) : null\n    }\n  }\n\n  vpc_config {\n    security_group_ids      = compact(distinct(concat(var.additional_security_group_ids, [local.security_group_id])))\n    subnet_ids              = coalescelist(var.control_plane_subnet_ids, var.subnet_ids)\n    endpoint_private_access = var.endpoint_private_access\n    endpoint_public_access  = var.endpoint_public_access\n    public_access_cidrs     = var.endpoint_public_access_cidrs\n  }\n\n  dynamic \"kubernetes_network_config\" {\n    # Not valid on Outposts\n    for_each = local.create_outposts_local_cluster ? [] : [1]\n\n    content {\n      dynamic \"elastic_load_balancing\" {\n        for_each = var.compute_config != null ? [var.compute_config] : []\n\n        content {\n          enabled = elastic_load_balancing.value.enabled\n        }\n      }\n\n      ip_family         = var.ip_family\n      service_ipv4_cidr = var.service_ipv4_cidr\n      service_ipv6_cidr = var.service_ipv6_cidr\n    }\n  }\n\n  dynamic \"outpost_config\" {\n    for_each = local.create_outposts_local_cluster ? [var.outpost_config] : []\n\n    content {\n      control_plane_instance_type = outpost_config.value.control_plane_instance_type\n\n      dynamic \"control_plane_placement\" {\n        for_each = outpost_config.value.control_plane_placement != null ? [outpost_config.value.control_plane_placement] : []\n\n        content {\n          group_name = control_plane_placement.value.group_name\n        }\n      }\n\n      outpost_arns = outpost_config.value.outpost_arns\n    }\n  }\n\n  dynamic \"encryption_config\" {\n    # Not available on Outposts\n    for_each = local.enable_encryption_config ? [var.encryption_config] : []\n\n    content {\n      provider {\n        key_arn = var.create_kms_key ? module.kms.key_arn : encryption_config.value.provider_key_arn\n      }\n      resources = encryption_config.value.resources\n    }\n  }\n\n  dynamic \"remote_network_config\" {\n    # Not valid on Outposts\n    for_each = var.remote_network_config != null && !local.create_outposts_local_cluster ? [var.remote_network_config] : []\n\n    content {\n      dynamic \"remote_node_networks\" {\n        for_each = [remote_network_config.value.remote_node_networks]\n\n        content {\n          cidrs = remote_node_networks.value.cidrs\n        }\n      }\n\n      dynamic \"remote_pod_networks\" {\n        for_each = remote_network_config.value.remote_pod_networks != null ? [remote_network_config.value.remote_pod_networks] : []\n\n        content {\n          cidrs = remote_pod_networks.value.cidrs\n        }\n      }\n    }\n  }\n\n  dynamic \"storage_config\" {\n    for_each = var.compute_config != null ? [var.compute_config] : []\n\n    content {\n      block_storage {\n        enabled = storage_config.value.enabled\n      }\n    }\n  }\n\n  dynamic \"upgrade_policy\" {\n    for_each = var.upgrade_policy != null ? [var.upgrade_policy] : []\n\n    content {\n      support_type = upgrade_policy.value.support_type\n    }\n  }\n\n  dynamic \"zonal_shift_config\" {\n    for_each = var.zonal_shift_config != null ? [var.zonal_shift_config] : []\n\n    content {\n      enabled = zonal_shift_config.value.enabled\n    }\n  }\n\n  tags = merge(\n    { terraform-aws-modules = \"eks\" },\n    var.tags,\n    var.cluster_tags,\n  )\n\n  dynamic \"timeouts\" {\n    for_each = var.timeouts != null ? [var.timeouts] : []\n\n    content {\n      create = var.timeouts.create\n      update = var.timeouts.update\n      delete = var.timeouts.delete\n    }\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_security_group_rule.cluster,\n    aws_security_group_rule.node,\n    aws_cloudwatch_log_group.this,\n    aws_iam_policy.cni_ipv6_policy,\n  ]\n\n  lifecycle {\n    ignore_changes = [\n      access_config[0].bootstrap_cluster_creator_admin_permissions,\n      bootstrap_self_managed_addons,\n    ]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_338", "ruleIndex": 8, "level": "error", "attachments": [], "message": {"text": "Ensure CloudWatch log groups retains logs for at least 1 year"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 223, "endLine": 238, "snippet": {"text": "resource \"aws_cloudwatch_log_group\" \"this\" {\n  count = local.create && var.create_cloudwatch_log_group ? 1 : 0\n\n  region = var.region\n\n  name              = \"/aws/eks/${var.name}/cluster\"\n  retention_in_days = var.cloudwatch_log_group_retention_in_days\n  kms_key_id        = var.cloudwatch_log_group_kms_key_id\n  log_group_class   = var.cloudwatch_log_group_class\n\n  tags = merge(\n    var.tags,\n    var.cloudwatch_log_group_tags,\n    { Name = \"/aws/eks/${var.name}/cluster\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV_AWS_79", "ruleIndex": 11, "level": "error", "attachments": [], "message": {"text": "Ensure Instance Metadata Service Version 1 is not enabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/eks-managed-node-group/main.tf"}, "region": {"startLine": 98, "endLine": 380, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template && var.use_custom_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"hibernation_options\" {\n  #   for_each = length(var.hibernation_options) > 0 ? [var.hibernation_options] : []\n\n  #   content {\n  #     configured = hibernation_options.value.configured\n  #   }\n  # }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"iam_instance_profile\" {\n  #   for_each = [var.iam_instance_profile]\n  #   content {\n  #     name = lookup(var.iam_instance_profile, \"name\", null)\n  #     arn  = lookup(var.iam_instance_profile, \"arn\", null)\n  #   }\n  # }\n\n  image_id = var.ami_id\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  # Instance type(s) are generally set on the node group,\n  # except when a ML capacity block reseravtion is used\n  instance_type = var.capacity_type == \"CAPACITY_BLOCK\" ? element(var.instance_types, 0) : null\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = merge(\n    var.tags,\n    var.launch_template_tags,\n  )\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_341", "ruleIndex": 12, "level": "error", "attachments": [], "message": {"text": "Ensure Launch template should not have a metadata response hop limit greater than 1"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/eks-managed-node-group/main.tf"}, "region": {"startLine": 98, "endLine": 380, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template && var.use_custom_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"hibernation_options\" {\n  #   for_each = length(var.hibernation_options) > 0 ? [var.hibernation_options] : []\n\n  #   content {\n  #     configured = hibernation_options.value.configured\n  #   }\n  # }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"iam_instance_profile\" {\n  #   for_each = [var.iam_instance_profile]\n  #   content {\n  #     name = lookup(var.iam_instance_profile, \"name\", null)\n  #     arn  = lookup(var.iam_instance_profile, \"arn\", null)\n  #   }\n  # }\n\n  image_id = var.ami_id\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  # Instance type(s) are generally set on the node group,\n  # except when a ML capacity block reseravtion is used\n  instance_type = var.capacity_type == \"CAPACITY_BLOCK\" ? element(var.instance_types, 0) : null\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = merge(\n    var.tags,\n    var.launch_template_tags,\n  )\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_79", "ruleIndex": 11, "level": "error", "attachments": [], "message": {"text": "Ensure Instance Metadata Service Version 1 is not enabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/eks-managed-node-group/main.tf"}, "region": {"startLine": 98, "endLine": 380, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template && var.use_custom_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"hibernation_options\" {\n  #   for_each = length(var.hibernation_options) > 0 ? [var.hibernation_options] : []\n\n  #   content {\n  #     configured = hibernation_options.value.configured\n  #   }\n  # }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"iam_instance_profile\" {\n  #   for_each = [var.iam_instance_profile]\n  #   content {\n  #     name = lookup(var.iam_instance_profile, \"name\", null)\n  #     arn  = lookup(var.iam_instance_profile, \"arn\", null)\n  #   }\n  # }\n\n  image_id = var.ami_id\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  # Instance type(s) are generally set on the node group,\n  # except when a ML capacity block reseravtion is used\n  instance_type = var.capacity_type == \"CAPACITY_BLOCK\" ? element(var.instance_types, 0) : null\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = merge(\n    var.tags,\n    var.launch_template_tags,\n  )\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_341", "ruleIndex": 12, "level": "error", "attachments": [], "message": {"text": "Ensure Launch template should not have a metadata response hop limit greater than 1"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/eks-managed-node-group/main.tf"}, "region": {"startLine": 98, "endLine": 380, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template && var.use_custom_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"hibernation_options\" {\n  #   for_each = length(var.hibernation_options) > 0 ? [var.hibernation_options] : []\n\n  #   content {\n  #     configured = hibernation_options.value.configured\n  #   }\n  # }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"iam_instance_profile\" {\n  #   for_each = [var.iam_instance_profile]\n  #   content {\n  #     name = lookup(var.iam_instance_profile, \"name\", null)\n  #     arn  = lookup(var.iam_instance_profile, \"arn\", null)\n  #   }\n  # }\n\n  image_id = var.ami_id\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  # Instance type(s) are generally set on the node group,\n  # except when a ML capacity block reseravtion is used\n  instance_type = var.capacity_type == \"CAPACITY_BLOCK\" ? element(var.instance_types, 0) : null\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = merge(\n    var.tags,\n    var.launch_template_tags,\n  )\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_79", "ruleIndex": 11, "level": "error", "attachments": [], "message": {"text": "Ensure Instance Metadata Service Version 1 is not enabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/eks-managed-node-group/main.tf"}, "region": {"startLine": 98, "endLine": 380, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template && var.use_custom_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"hibernation_options\" {\n  #   for_each = length(var.hibernation_options) > 0 ? [var.hibernation_options] : []\n\n  #   content {\n  #     configured = hibernation_options.value.configured\n  #   }\n  # }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"iam_instance_profile\" {\n  #   for_each = [var.iam_instance_profile]\n  #   content {\n  #     name = lookup(var.iam_instance_profile, \"name\", null)\n  #     arn  = lookup(var.iam_instance_profile, \"arn\", null)\n  #   }\n  # }\n\n  image_id = var.ami_id\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  # Instance type(s) are generally set on the node group,\n  # except when a ML capacity block reseravtion is used\n  instance_type = var.capacity_type == \"CAPACITY_BLOCK\" ? element(var.instance_types, 0) : null\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = merge(\n    var.tags,\n    var.launch_template_tags,\n  )\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_341", "ruleIndex": 12, "level": "error", "attachments": [], "message": {"text": "Ensure Launch template should not have a metadata response hop limit greater than 1"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/eks-managed-node-group/main.tf"}, "region": {"startLine": 98, "endLine": 380, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template && var.use_custom_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"hibernation_options\" {\n  #   for_each = length(var.hibernation_options) > 0 ? [var.hibernation_options] : []\n\n  #   content {\n  #     configured = hibernation_options.value.configured\n  #   }\n  # }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"iam_instance_profile\" {\n  #   for_each = [var.iam_instance_profile]\n  #   content {\n  #     name = lookup(var.iam_instance_profile, \"name\", null)\n  #     arn  = lookup(var.iam_instance_profile, \"arn\", null)\n  #   }\n  # }\n\n  image_id = var.ami_id\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  # Instance type(s) are generally set on the node group,\n  # except when a ML capacity block reseravtion is used\n  instance_type = var.capacity_type == \"CAPACITY_BLOCK\" ? element(var.instance_types, 0) : null\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = merge(\n    var.tags,\n    var.launch_template_tags,\n  )\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_79", "ruleIndex": 11, "level": "error", "attachments": [], "message": {"text": "Ensure Instance Metadata Service Version 1 is not enabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/eks-managed-node-group/main.tf"}, "region": {"startLine": 98, "endLine": 380, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template && var.use_custom_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"hibernation_options\" {\n  #   for_each = length(var.hibernation_options) > 0 ? [var.hibernation_options] : []\n\n  #   content {\n  #     configured = hibernation_options.value.configured\n  #   }\n  # }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"iam_instance_profile\" {\n  #   for_each = [var.iam_instance_profile]\n  #   content {\n  #     name = lookup(var.iam_instance_profile, \"name\", null)\n  #     arn  = lookup(var.iam_instance_profile, \"arn\", null)\n  #   }\n  # }\n\n  image_id = var.ami_id\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  # Instance type(s) are generally set on the node group,\n  # except when a ML capacity block reseravtion is used\n  instance_type = var.capacity_type == \"CAPACITY_BLOCK\" ? element(var.instance_types, 0) : null\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = merge(\n    var.tags,\n    var.launch_template_tags,\n  )\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_341", "ruleIndex": 12, "level": "error", "attachments": [], "message": {"text": "Ensure Launch template should not have a metadata response hop limit greater than 1"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/eks-managed-node-group/main.tf"}, "region": {"startLine": 98, "endLine": 380, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template && var.use_custom_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"hibernation_options\" {\n  #   for_each = length(var.hibernation_options) > 0 ? [var.hibernation_options] : []\n\n  #   content {\n  #     configured = hibernation_options.value.configured\n  #   }\n  # }\n\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # dynamic \"iam_instance_profile\" {\n  #   for_each = [var.iam_instance_profile]\n  #   content {\n  #     name = lookup(var.iam_instance_profile, \"name\", null)\n  #     arn  = lookup(var.iam_instance_profile, \"arn\", null)\n  #   }\n  # }\n\n  image_id = var.ami_id\n  # Set on EKS managed node group, will fail if set here\n  # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n  # instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  # Instance type(s) are generally set on the node group,\n  # except when a ML capacity block reseravtion is used\n  instance_type = var.capacity_type == \"CAPACITY_BLOCK\" ? element(var.instance_types, 0) : null\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = merge(\n    var.tags,\n    var.launch_template_tags,\n  )\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_111", "ruleIndex": 13, "level": "error", "attachments": [], "message": {"text": "Ensure IAM policies does not allow write access without constraints"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/hybrid-node-role/main.tf"}, "region": {"startLine": 93, "endLine": 159, "snippet": {"text": "data \"aws_iam_policy_document\" \"this\" {\n  count = var.create ? 1 : 0\n\n  statement {\n    actions = [\n      \"ssm:DeregisterManagedInstance\",\n      \"ssm:DescribeInstanceInformation\",\n    ]\n\n    resources = [\"*\"]\n  }\n\n  statement {\n    actions   = [\"eks:DescribeCluster\"]\n    resources = var.cluster_arns\n  }\n\n  dynamic \"statement\" {\n    for_each = var.enable_pod_identity ? [1] : []\n\n    content {\n      actions   = [\"eks-auth:AssumeRoleForPodIdentity\"]\n      resources = [\"*\"]\n    }\n  }\n\n  dynamic \"statement\" {\n    for_each = var.policy_statements != null ? var.policy_statements : []\n\n    content {\n      sid           = statement.value.sid\n      actions       = statement.value.actions\n      not_actions   = statement.value.not_actions\n      effect        = statement.value.effect\n      resources     = statement.value.resources\n      not_resources = statement.value.not_resources\n\n      dynamic \"principals\" {\n        for_each = statement.value.principals != null ? statement.value.principals : []\n\n        content {\n          type        = principals.value.type\n          identifiers = principals.value.identifiers\n        }\n      }\n\n      dynamic \"not_principals\" {\n        for_each = statement.value.not_principals != null ? statement.value.not_principals : []\n\n        content {\n          type        = not_principals.value.type\n          identifiers = not_principals.value.identifiers\n        }\n      }\n\n      dynamic \"condition\" {\n        for_each = statement.value.condition != null ? statement.value.condition : []\n\n        content {\n          test     = condition.value.test\n          values   = condition.value.values\n          variable = condition.value.variable\n        }\n      }\n    }\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_356", "ruleIndex": 14, "level": "error", "attachments": [], "message": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/hybrid-node-role/main.tf"}, "region": {"startLine": 93, "endLine": 159, "snippet": {"text": "data \"aws_iam_policy_document\" \"this\" {\n  count = var.create ? 1 : 0\n\n  statement {\n    actions = [\n      \"ssm:DeregisterManagedInstance\",\n      \"ssm:DescribeInstanceInformation\",\n    ]\n\n    resources = [\"*\"]\n  }\n\n  statement {\n    actions   = [\"eks:DescribeCluster\"]\n    resources = var.cluster_arns\n  }\n\n  dynamic \"statement\" {\n    for_each = var.enable_pod_identity ? [1] : []\n\n    content {\n      actions   = [\"eks-auth:AssumeRoleForPodIdentity\"]\n      resources = [\"*\"]\n    }\n  }\n\n  dynamic \"statement\" {\n    for_each = var.policy_statements != null ? var.policy_statements : []\n\n    content {\n      sid           = statement.value.sid\n      actions       = statement.value.actions\n      not_actions   = statement.value.not_actions\n      effect        = statement.value.effect\n      resources     = statement.value.resources\n      not_resources = statement.value.not_resources\n\n      dynamic \"principals\" {\n        for_each = statement.value.principals != null ? statement.value.principals : []\n\n        content {\n          type        = principals.value.type\n          identifiers = principals.value.identifiers\n        }\n      }\n\n      dynamic \"not_principals\" {\n        for_each = statement.value.not_principals != null ? statement.value.not_principals : []\n\n        content {\n          type        = not_principals.value.type\n          identifiers = not_principals.value.identifiers\n        }\n      }\n\n      dynamic \"condition\" {\n        for_each = statement.value.condition != null ? statement.value.condition : []\n\n        content {\n          test     = condition.value.test\n          values   = condition.value.values\n          variable = condition.value.variable\n        }\n      }\n    }\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_111", "ruleIndex": 13, "level": "error", "attachments": [], "message": {"text": "Ensure IAM policies does not allow write access without constraints"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/hybrid-node-role/main.tf"}, "region": {"startLine": 93, "endLine": 159, "snippet": {"text": "data \"aws_iam_policy_document\" \"this\" {\n  count = var.create ? 1 : 0\n\n  statement {\n    actions = [\n      \"ssm:DeregisterManagedInstance\",\n      \"ssm:DescribeInstanceInformation\",\n    ]\n\n    resources = [\"*\"]\n  }\n\n  statement {\n    actions   = [\"eks:DescribeCluster\"]\n    resources = var.cluster_arns\n  }\n\n  dynamic \"statement\" {\n    for_each = var.enable_pod_identity ? [1] : []\n\n    content {\n      actions   = [\"eks-auth:AssumeRoleForPodIdentity\"]\n      resources = [\"*\"]\n    }\n  }\n\n  dynamic \"statement\" {\n    for_each = var.policy_statements != null ? var.policy_statements : []\n\n    content {\n      sid           = statement.value.sid\n      actions       = statement.value.actions\n      not_actions   = statement.value.not_actions\n      effect        = statement.value.effect\n      resources     = statement.value.resources\n      not_resources = statement.value.not_resources\n\n      dynamic \"principals\" {\n        for_each = statement.value.principals != null ? statement.value.principals : []\n\n        content {\n          type        = principals.value.type\n          identifiers = principals.value.identifiers\n        }\n      }\n\n      dynamic \"not_principals\" {\n        for_each = statement.value.not_principals != null ? statement.value.not_principals : []\n\n        content {\n          type        = not_principals.value.type\n          identifiers = not_principals.value.identifiers\n        }\n      }\n\n      dynamic \"condition\" {\n        for_each = statement.value.condition != null ? statement.value.condition : []\n\n        content {\n          test     = condition.value.test\n          values   = condition.value.values\n          variable = condition.value.variable\n        }\n      }\n    }\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_356", "ruleIndex": 14, "level": "error", "attachments": [], "message": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/hybrid-node-role/main.tf"}, "region": {"startLine": 93, "endLine": 159, "snippet": {"text": "data \"aws_iam_policy_document\" \"this\" {\n  count = var.create ? 1 : 0\n\n  statement {\n    actions = [\n      \"ssm:DeregisterManagedInstance\",\n      \"ssm:DescribeInstanceInformation\",\n    ]\n\n    resources = [\"*\"]\n  }\n\n  statement {\n    actions   = [\"eks:DescribeCluster\"]\n    resources = var.cluster_arns\n  }\n\n  dynamic \"statement\" {\n    for_each = var.enable_pod_identity ? [1] : []\n\n    content {\n      actions   = [\"eks-auth:AssumeRoleForPodIdentity\"]\n      resources = [\"*\"]\n    }\n  }\n\n  dynamic \"statement\" {\n    for_each = var.policy_statements != null ? var.policy_statements : []\n\n    content {\n      sid           = statement.value.sid\n      actions       = statement.value.actions\n      not_actions   = statement.value.not_actions\n      effect        = statement.value.effect\n      resources     = statement.value.resources\n      not_resources = statement.value.not_resources\n\n      dynamic \"principals\" {\n        for_each = statement.value.principals != null ? statement.value.principals : []\n\n        content {\n          type        = principals.value.type\n          identifiers = principals.value.identifiers\n        }\n      }\n\n      dynamic \"not_principals\" {\n        for_each = statement.value.not_principals != null ? statement.value.not_principals : []\n\n        content {\n          type        = not_principals.value.type\n          identifiers = not_principals.value.identifiers\n        }\n      }\n\n      dynamic \"condition\" {\n        for_each = statement.value.condition != null ? statement.value.condition : []\n\n        content {\n          test     = condition.value.test\n          values   = condition.value.values\n          variable = condition.value.variable\n        }\n      }\n    }\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_79", "ruleIndex": 11, "level": "error", "attachments": [], "message": {"text": "Ensure Instance Metadata Service Version 1 is not enabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/self-managed-node-group/main.tf"}, "region": {"startLine": 139, "endLine": 495, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  iam_instance_profile {\n    arn = var.create_iam_instance_profile ? aws_iam_instance_profile.this[0].arn : var.iam_instance_profile_arn\n  }\n\n  image_id                             = coalesce(var.ami_id, nonsensitive(data.aws_ssm_parameter.ami[0].value))\n  instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  dynamic \"instance_requirements\" {\n    for_each = var.instance_requirements != null ? [var.instance_requirements] : []\n\n    content {\n      dynamic \"accelerator_count\" {\n        for_each = instance_requirements.value.accelerator_count != null ? [instance_requirements.value.accelerator_count] : []\n\n        content {\n          max = accelerator_count.value.max\n          min = accelerator_count.value.min\n        }\n      }\n\n      accelerator_manufacturers = instance_requirements.value.accelerator_manufacturers\n      accelerator_names         = instance_requirements.value.accelerator_names\n\n      dynamic \"accelerator_total_memory_mib\" {\n        for_each = instance_requirements.value.accelerator_total_memory_mib != null ? [instance_requirements.value.accelerator_total_memory_mib] : []\n\n        content {\n          max = accelerator_total_memory_mib.value.max\n          min = accelerator_total_memory_mib.value.min\n        }\n      }\n\n      accelerator_types      = instance_requirements.value.accelerator_types\n      allowed_instance_types = instance_requirements.value.allowed_instance_types\n      bare_metal             = instance_requirements.value.bare_metal\n\n      dynamic \"baseline_ebs_bandwidth_mbps\" {\n        for_each = instance_requirements.value.baseline_ebs_bandwidth_mbps != null ? [instance_requirements.value.baseline_ebs_bandwidth_mbps] : []\n\n        content {\n          max = baseline_ebs_bandwidth_mbps.value.max\n          min = baseline_ebs_bandwidth_mbps.value.min\n        }\n      }\n\n      burstable_performance                                   = instance_requirements.value.burstable_performance\n      cpu_manufacturers                                       = instance_requirements.value.cpu_manufacturers\n      excluded_instance_types                                 = instance_requirements.value.excluded_instance_types\n      instance_generations                                    = instance_requirements.value.instance_generations\n      local_storage                                           = instance_requirements.value.local_storage\n      local_storage_types                                     = instance_requirements.value.local_storage_types\n      max_spot_price_as_percentage_of_optimal_on_demand_price = instance_requirements.value.max_spot_price_as_percentage_of_optimal_on_demand_price\n\n      dynamic \"memory_gib_per_vcpu\" {\n        for_each = instance_requirements.value.memory_gib_per_vcpu != null ? [instance_requirements.value.memory_gib_per_vcpu] : []\n\n        content {\n          max = memory_gib_per_vcpu.value.max\n          min = memory_gib_per_vcpu.value.min\n        }\n      }\n\n      dynamic \"memory_mib\" {\n        for_each = instance_requirements.value.memory_mib != null ? [instance_requirements.value.memory_mib] : []\n\n        content {\n          max = memory_mib.value.max\n          min = memory_mib.value.min\n        }\n      }\n\n      dynamic \"network_interface_count\" {\n        for_each = instance_requirements.value.network_interface_count != null ? [instance_requirements.value.network_interface_count] : []\n\n        content {\n          max = network_interface_count.value.max\n          min = network_interface_count.value.min\n        }\n      }\n\n      on_demand_max_price_percentage_over_lowest_price = instance_requirements.value.on_demand_max_price_percentage_over_lowest_price\n      require_hibernate_support                        = instance_requirements.value.require_hibernate_support\n      spot_max_price_percentage_over_lowest_price      = instance_requirements.value.spot_max_price_percentage_over_lowest_price\n\n      dynamic \"total_local_storage_gb\" {\n        for_each = instance_requirements.value.total_local_storage_gb != null ? [instance_requirements.value.total_local_storage_gb] : []\n\n        content {\n          max = total_local_storage_gb.value.max\n          min = total_local_storage_gb.value.min\n        }\n      }\n\n      dynamic \"vcpu_count\" {\n        for_each = instance_requirements.value.vcpu_count != null ? [instance_requirements.value.vcpu_count] : []\n\n        content {\n          max = vcpu_count.value.max\n          min = vcpu_count.value.min\n        }\n      }\n    }\n  }\n\n  instance_type = var.instance_requirements != null ? null : var.instance_type\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = var.tags\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_341", "ruleIndex": 12, "level": "error", "attachments": [], "message": {"text": "Ensure Launch template should not have a metadata response hop limit greater than 1"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/self-managed-node-group/main.tf"}, "region": {"startLine": 139, "endLine": 495, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  iam_instance_profile {\n    arn = var.create_iam_instance_profile ? aws_iam_instance_profile.this[0].arn : var.iam_instance_profile_arn\n  }\n\n  image_id                             = coalesce(var.ami_id, nonsensitive(data.aws_ssm_parameter.ami[0].value))\n  instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  dynamic \"instance_requirements\" {\n    for_each = var.instance_requirements != null ? [var.instance_requirements] : []\n\n    content {\n      dynamic \"accelerator_count\" {\n        for_each = instance_requirements.value.accelerator_count != null ? [instance_requirements.value.accelerator_count] : []\n\n        content {\n          max = accelerator_count.value.max\n          min = accelerator_count.value.min\n        }\n      }\n\n      accelerator_manufacturers = instance_requirements.value.accelerator_manufacturers\n      accelerator_names         = instance_requirements.value.accelerator_names\n\n      dynamic \"accelerator_total_memory_mib\" {\n        for_each = instance_requirements.value.accelerator_total_memory_mib != null ? [instance_requirements.value.accelerator_total_memory_mib] : []\n\n        content {\n          max = accelerator_total_memory_mib.value.max\n          min = accelerator_total_memory_mib.value.min\n        }\n      }\n\n      accelerator_types      = instance_requirements.value.accelerator_types\n      allowed_instance_types = instance_requirements.value.allowed_instance_types\n      bare_metal             = instance_requirements.value.bare_metal\n\n      dynamic \"baseline_ebs_bandwidth_mbps\" {\n        for_each = instance_requirements.value.baseline_ebs_bandwidth_mbps != null ? [instance_requirements.value.baseline_ebs_bandwidth_mbps] : []\n\n        content {\n          max = baseline_ebs_bandwidth_mbps.value.max\n          min = baseline_ebs_bandwidth_mbps.value.min\n        }\n      }\n\n      burstable_performance                                   = instance_requirements.value.burstable_performance\n      cpu_manufacturers                                       = instance_requirements.value.cpu_manufacturers\n      excluded_instance_types                                 = instance_requirements.value.excluded_instance_types\n      instance_generations                                    = instance_requirements.value.instance_generations\n      local_storage                                           = instance_requirements.value.local_storage\n      local_storage_types                                     = instance_requirements.value.local_storage_types\n      max_spot_price_as_percentage_of_optimal_on_demand_price = instance_requirements.value.max_spot_price_as_percentage_of_optimal_on_demand_price\n\n      dynamic \"memory_gib_per_vcpu\" {\n        for_each = instance_requirements.value.memory_gib_per_vcpu != null ? [instance_requirements.value.memory_gib_per_vcpu] : []\n\n        content {\n          max = memory_gib_per_vcpu.value.max\n          min = memory_gib_per_vcpu.value.min\n        }\n      }\n\n      dynamic \"memory_mib\" {\n        for_each = instance_requirements.value.memory_mib != null ? [instance_requirements.value.memory_mib] : []\n\n        content {\n          max = memory_mib.value.max\n          min = memory_mib.value.min\n        }\n      }\n\n      dynamic \"network_interface_count\" {\n        for_each = instance_requirements.value.network_interface_count != null ? [instance_requirements.value.network_interface_count] : []\n\n        content {\n          max = network_interface_count.value.max\n          min = network_interface_count.value.min\n        }\n      }\n\n      on_demand_max_price_percentage_over_lowest_price = instance_requirements.value.on_demand_max_price_percentage_over_lowest_price\n      require_hibernate_support                        = instance_requirements.value.require_hibernate_support\n      spot_max_price_percentage_over_lowest_price      = instance_requirements.value.spot_max_price_percentage_over_lowest_price\n\n      dynamic \"total_local_storage_gb\" {\n        for_each = instance_requirements.value.total_local_storage_gb != null ? [instance_requirements.value.total_local_storage_gb] : []\n\n        content {\n          max = total_local_storage_gb.value.max\n          min = total_local_storage_gb.value.min\n        }\n      }\n\n      dynamic \"vcpu_count\" {\n        for_each = instance_requirements.value.vcpu_count != null ? [instance_requirements.value.vcpu_count] : []\n\n        content {\n          max = vcpu_count.value.max\n          min = vcpu_count.value.min\n        }\n      }\n    }\n  }\n\n  instance_type = var.instance_requirements != null ? null : var.instance_type\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = var.tags\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_79", "ruleIndex": 11, "level": "error", "attachments": [], "message": {"text": "Ensure Instance Metadata Service Version 1 is not enabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/self-managed-node-group/main.tf"}, "region": {"startLine": 139, "endLine": 495, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  iam_instance_profile {\n    arn = var.create_iam_instance_profile ? aws_iam_instance_profile.this[0].arn : var.iam_instance_profile_arn\n  }\n\n  image_id                             = coalesce(var.ami_id, nonsensitive(data.aws_ssm_parameter.ami[0].value))\n  instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  dynamic \"instance_requirements\" {\n    for_each = var.instance_requirements != null ? [var.instance_requirements] : []\n\n    content {\n      dynamic \"accelerator_count\" {\n        for_each = instance_requirements.value.accelerator_count != null ? [instance_requirements.value.accelerator_count] : []\n\n        content {\n          max = accelerator_count.value.max\n          min = accelerator_count.value.min\n        }\n      }\n\n      accelerator_manufacturers = instance_requirements.value.accelerator_manufacturers\n      accelerator_names         = instance_requirements.value.accelerator_names\n\n      dynamic \"accelerator_total_memory_mib\" {\n        for_each = instance_requirements.value.accelerator_total_memory_mib != null ? [instance_requirements.value.accelerator_total_memory_mib] : []\n\n        content {\n          max = accelerator_total_memory_mib.value.max\n          min = accelerator_total_memory_mib.value.min\n        }\n      }\n\n      accelerator_types      = instance_requirements.value.accelerator_types\n      allowed_instance_types = instance_requirements.value.allowed_instance_types\n      bare_metal             = instance_requirements.value.bare_metal\n\n      dynamic \"baseline_ebs_bandwidth_mbps\" {\n        for_each = instance_requirements.value.baseline_ebs_bandwidth_mbps != null ? [instance_requirements.value.baseline_ebs_bandwidth_mbps] : []\n\n        content {\n          max = baseline_ebs_bandwidth_mbps.value.max\n          min = baseline_ebs_bandwidth_mbps.value.min\n        }\n      }\n\n      burstable_performance                                   = instance_requirements.value.burstable_performance\n      cpu_manufacturers                                       = instance_requirements.value.cpu_manufacturers\n      excluded_instance_types                                 = instance_requirements.value.excluded_instance_types\n      instance_generations                                    = instance_requirements.value.instance_generations\n      local_storage                                           = instance_requirements.value.local_storage\n      local_storage_types                                     = instance_requirements.value.local_storage_types\n      max_spot_price_as_percentage_of_optimal_on_demand_price = instance_requirements.value.max_spot_price_as_percentage_of_optimal_on_demand_price\n\n      dynamic \"memory_gib_per_vcpu\" {\n        for_each = instance_requirements.value.memory_gib_per_vcpu != null ? [instance_requirements.value.memory_gib_per_vcpu] : []\n\n        content {\n          max = memory_gib_per_vcpu.value.max\n          min = memory_gib_per_vcpu.value.min\n        }\n      }\n\n      dynamic \"memory_mib\" {\n        for_each = instance_requirements.value.memory_mib != null ? [instance_requirements.value.memory_mib] : []\n\n        content {\n          max = memory_mib.value.max\n          min = memory_mib.value.min\n        }\n      }\n\n      dynamic \"network_interface_count\" {\n        for_each = instance_requirements.value.network_interface_count != null ? [instance_requirements.value.network_interface_count] : []\n\n        content {\n          max = network_interface_count.value.max\n          min = network_interface_count.value.min\n        }\n      }\n\n      on_demand_max_price_percentage_over_lowest_price = instance_requirements.value.on_demand_max_price_percentage_over_lowest_price\n      require_hibernate_support                        = instance_requirements.value.require_hibernate_support\n      spot_max_price_percentage_over_lowest_price      = instance_requirements.value.spot_max_price_percentage_over_lowest_price\n\n      dynamic \"total_local_storage_gb\" {\n        for_each = instance_requirements.value.total_local_storage_gb != null ? [instance_requirements.value.total_local_storage_gb] : []\n\n        content {\n          max = total_local_storage_gb.value.max\n          min = total_local_storage_gb.value.min\n        }\n      }\n\n      dynamic \"vcpu_count\" {\n        for_each = instance_requirements.value.vcpu_count != null ? [instance_requirements.value.vcpu_count] : []\n\n        content {\n          max = vcpu_count.value.max\n          min = vcpu_count.value.min\n        }\n      }\n    }\n  }\n\n  instance_type = var.instance_requirements != null ? null : var.instance_type\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = var.tags\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_341", "ruleIndex": 12, "level": "error", "attachments": [], "message": {"text": "Ensure Launch template should not have a metadata response hop limit greater than 1"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/self-managed-node-group/main.tf"}, "region": {"startLine": 139, "endLine": 495, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  iam_instance_profile {\n    arn = var.create_iam_instance_profile ? aws_iam_instance_profile.this[0].arn : var.iam_instance_profile_arn\n  }\n\n  image_id                             = coalesce(var.ami_id, nonsensitive(data.aws_ssm_parameter.ami[0].value))\n  instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  dynamic \"instance_requirements\" {\n    for_each = var.instance_requirements != null ? [var.instance_requirements] : []\n\n    content {\n      dynamic \"accelerator_count\" {\n        for_each = instance_requirements.value.accelerator_count != null ? [instance_requirements.value.accelerator_count] : []\n\n        content {\n          max = accelerator_count.value.max\n          min = accelerator_count.value.min\n        }\n      }\n\n      accelerator_manufacturers = instance_requirements.value.accelerator_manufacturers\n      accelerator_names         = instance_requirements.value.accelerator_names\n\n      dynamic \"accelerator_total_memory_mib\" {\n        for_each = instance_requirements.value.accelerator_total_memory_mib != null ? [instance_requirements.value.accelerator_total_memory_mib] : []\n\n        content {\n          max = accelerator_total_memory_mib.value.max\n          min = accelerator_total_memory_mib.value.min\n        }\n      }\n\n      accelerator_types      = instance_requirements.value.accelerator_types\n      allowed_instance_types = instance_requirements.value.allowed_instance_types\n      bare_metal             = instance_requirements.value.bare_metal\n\n      dynamic \"baseline_ebs_bandwidth_mbps\" {\n        for_each = instance_requirements.value.baseline_ebs_bandwidth_mbps != null ? [instance_requirements.value.baseline_ebs_bandwidth_mbps] : []\n\n        content {\n          max = baseline_ebs_bandwidth_mbps.value.max\n          min = baseline_ebs_bandwidth_mbps.value.min\n        }\n      }\n\n      burstable_performance                                   = instance_requirements.value.burstable_performance\n      cpu_manufacturers                                       = instance_requirements.value.cpu_manufacturers\n      excluded_instance_types                                 = instance_requirements.value.excluded_instance_types\n      instance_generations                                    = instance_requirements.value.instance_generations\n      local_storage                                           = instance_requirements.value.local_storage\n      local_storage_types                                     = instance_requirements.value.local_storage_types\n      max_spot_price_as_percentage_of_optimal_on_demand_price = instance_requirements.value.max_spot_price_as_percentage_of_optimal_on_demand_price\n\n      dynamic \"memory_gib_per_vcpu\" {\n        for_each = instance_requirements.value.memory_gib_per_vcpu != null ? [instance_requirements.value.memory_gib_per_vcpu] : []\n\n        content {\n          max = memory_gib_per_vcpu.value.max\n          min = memory_gib_per_vcpu.value.min\n        }\n      }\n\n      dynamic \"memory_mib\" {\n        for_each = instance_requirements.value.memory_mib != null ? [instance_requirements.value.memory_mib] : []\n\n        content {\n          max = memory_mib.value.max\n          min = memory_mib.value.min\n        }\n      }\n\n      dynamic \"network_interface_count\" {\n        for_each = instance_requirements.value.network_interface_count != null ? [instance_requirements.value.network_interface_count] : []\n\n        content {\n          max = network_interface_count.value.max\n          min = network_interface_count.value.min\n        }\n      }\n\n      on_demand_max_price_percentage_over_lowest_price = instance_requirements.value.on_demand_max_price_percentage_over_lowest_price\n      require_hibernate_support                        = instance_requirements.value.require_hibernate_support\n      spot_max_price_percentage_over_lowest_price      = instance_requirements.value.spot_max_price_percentage_over_lowest_price\n\n      dynamic \"total_local_storage_gb\" {\n        for_each = instance_requirements.value.total_local_storage_gb != null ? [instance_requirements.value.total_local_storage_gb] : []\n\n        content {\n          max = total_local_storage_gb.value.max\n          min = total_local_storage_gb.value.min\n        }\n      }\n\n      dynamic \"vcpu_count\" {\n        for_each = instance_requirements.value.vcpu_count != null ? [instance_requirements.value.vcpu_count] : []\n\n        content {\n          max = vcpu_count.value.max\n          min = vcpu_count.value.min\n        }\n      }\n    }\n  }\n\n  instance_type = var.instance_requirements != null ? null : var.instance_type\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = var.tags\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_79", "ruleIndex": 11, "level": "error", "attachments": [], "message": {"text": "Ensure Instance Metadata Service Version 1 is not enabled"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/self-managed-node-group/main.tf"}, "region": {"startLine": 139, "endLine": 495, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  iam_instance_profile {\n    arn = var.create_iam_instance_profile ? aws_iam_instance_profile.this[0].arn : var.iam_instance_profile_arn\n  }\n\n  image_id                             = coalesce(var.ami_id, nonsensitive(data.aws_ssm_parameter.ami[0].value))\n  instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  dynamic \"instance_requirements\" {\n    for_each = var.instance_requirements != null ? [var.instance_requirements] : []\n\n    content {\n      dynamic \"accelerator_count\" {\n        for_each = instance_requirements.value.accelerator_count != null ? [instance_requirements.value.accelerator_count] : []\n\n        content {\n          max = accelerator_count.value.max\n          min = accelerator_count.value.min\n        }\n      }\n\n      accelerator_manufacturers = instance_requirements.value.accelerator_manufacturers\n      accelerator_names         = instance_requirements.value.accelerator_names\n\n      dynamic \"accelerator_total_memory_mib\" {\n        for_each = instance_requirements.value.accelerator_total_memory_mib != null ? [instance_requirements.value.accelerator_total_memory_mib] : []\n\n        content {\n          max = accelerator_total_memory_mib.value.max\n          min = accelerator_total_memory_mib.value.min\n        }\n      }\n\n      accelerator_types      = instance_requirements.value.accelerator_types\n      allowed_instance_types = instance_requirements.value.allowed_instance_types\n      bare_metal             = instance_requirements.value.bare_metal\n\n      dynamic \"baseline_ebs_bandwidth_mbps\" {\n        for_each = instance_requirements.value.baseline_ebs_bandwidth_mbps != null ? [instance_requirements.value.baseline_ebs_bandwidth_mbps] : []\n\n        content {\n          max = baseline_ebs_bandwidth_mbps.value.max\n          min = baseline_ebs_bandwidth_mbps.value.min\n        }\n      }\n\n      burstable_performance                                   = instance_requirements.value.burstable_performance\n      cpu_manufacturers                                       = instance_requirements.value.cpu_manufacturers\n      excluded_instance_types                                 = instance_requirements.value.excluded_instance_types\n      instance_generations                                    = instance_requirements.value.instance_generations\n      local_storage                                           = instance_requirements.value.local_storage\n      local_storage_types                                     = instance_requirements.value.local_storage_types\n      max_spot_price_as_percentage_of_optimal_on_demand_price = instance_requirements.value.max_spot_price_as_percentage_of_optimal_on_demand_price\n\n      dynamic \"memory_gib_per_vcpu\" {\n        for_each = instance_requirements.value.memory_gib_per_vcpu != null ? [instance_requirements.value.memory_gib_per_vcpu] : []\n\n        content {\n          max = memory_gib_per_vcpu.value.max\n          min = memory_gib_per_vcpu.value.min\n        }\n      }\n\n      dynamic \"memory_mib\" {\n        for_each = instance_requirements.value.memory_mib != null ? [instance_requirements.value.memory_mib] : []\n\n        content {\n          max = memory_mib.value.max\n          min = memory_mib.value.min\n        }\n      }\n\n      dynamic \"network_interface_count\" {\n        for_each = instance_requirements.value.network_interface_count != null ? [instance_requirements.value.network_interface_count] : []\n\n        content {\n          max = network_interface_count.value.max\n          min = network_interface_count.value.min\n        }\n      }\n\n      on_demand_max_price_percentage_over_lowest_price = instance_requirements.value.on_demand_max_price_percentage_over_lowest_price\n      require_hibernate_support                        = instance_requirements.value.require_hibernate_support\n      spot_max_price_percentage_over_lowest_price      = instance_requirements.value.spot_max_price_percentage_over_lowest_price\n\n      dynamic \"total_local_storage_gb\" {\n        for_each = instance_requirements.value.total_local_storage_gb != null ? [instance_requirements.value.total_local_storage_gb] : []\n\n        content {\n          max = total_local_storage_gb.value.max\n          min = total_local_storage_gb.value.min\n        }\n      }\n\n      dynamic \"vcpu_count\" {\n        for_each = instance_requirements.value.vcpu_count != null ? [instance_requirements.value.vcpu_count] : []\n\n        content {\n          max = vcpu_count.value.max\n          min = vcpu_count.value.min\n        }\n      }\n    }\n  }\n\n  instance_type = var.instance_requirements != null ? null : var.instance_type\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = var.tags\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_341", "ruleIndex": 12, "level": "error", "attachments": [], "message": {"text": "Ensure Launch template should not have a metadata response hop limit greater than 1"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/self-managed-node-group/main.tf"}, "region": {"startLine": 139, "endLine": 495, "snippet": {"text": "resource \"aws_launch_template\" \"this\" {\n  count = var.create && var.create_launch_template ? 1 : 0\n\n  region = var.region\n\n  dynamic \"block_device_mappings\" {\n    for_each = var.block_device_mappings != null ? var.block_device_mappings : {}\n\n    content {\n      device_name = block_device_mappings.value.device_name\n\n      dynamic \"ebs\" {\n        for_each = block_device_mappings.value.ebs != null ? [block_device_mappings.value.ebs] : []\n\n        content {\n          delete_on_termination      = ebs.value.delete_on_termination\n          encrypted                  = ebs.value.encrypted\n          iops                       = ebs.value.iops\n          kms_key_id                 = ebs.value.kms_key_id\n          snapshot_id                = ebs.value.snapshot_id\n          throughput                 = ebs.value.throughput\n          volume_initialization_rate = ebs.value.volume_initialization_rate\n          volume_size                = ebs.value.volume_size\n          volume_type                = ebs.value.volume_type\n        }\n      }\n\n      no_device    = block_device_mappings.value.no_device\n      virtual_name = block_device_mappings.value.virtual_name\n    }\n  }\n\n  dynamic \"capacity_reservation_specification\" {\n    for_each = var.capacity_reservation_specification != null ? [var.capacity_reservation_specification] : []\n\n    content {\n      capacity_reservation_preference = capacity_reservation_specification.value.capacity_reservation_preference\n\n      dynamic \"capacity_reservation_target\" {\n        for_each = capacity_reservation_specification.value.capacity_reservation_target != null ? [capacity_reservation_specification.value.capacity_reservation_target] : []\n        content {\n          capacity_reservation_id                 = capacity_reservation_target.value.capacity_reservation_id\n          capacity_reservation_resource_group_arn = capacity_reservation_target.value.capacity_reservation_resource_group_arn\n        }\n      }\n    }\n  }\n\n  dynamic \"cpu_options\" {\n    for_each = var.cpu_options != null ? [var.cpu_options] : []\n\n    content {\n      amd_sev_snp      = cpu_options.value.amd_sev_snp\n      core_count       = cpu_options.value.core_count\n      threads_per_core = cpu_options.value.threads_per_core\n    }\n  }\n\n  dynamic \"credit_specification\" {\n    for_each = var.credit_specification != null ? [var.credit_specification] : []\n\n    content {\n      cpu_credits = credit_specification.value.cpu_credits\n    }\n  }\n\n  default_version         = var.launch_template_default_version\n  description             = var.launch_template_description\n  disable_api_termination = var.disable_api_termination\n  ebs_optimized           = var.ebs_optimized\n\n  dynamic \"enclave_options\" {\n    for_each = var.enclave_options != null ? [var.enclave_options] : []\n\n    content {\n      enabled = enclave_options.value.enabled\n    }\n  }\n\n  iam_instance_profile {\n    arn = var.create_iam_instance_profile ? aws_iam_instance_profile.this[0].arn : var.iam_instance_profile_arn\n  }\n\n  image_id                             = coalesce(var.ami_id, nonsensitive(data.aws_ssm_parameter.ami[0].value))\n  instance_initiated_shutdown_behavior = var.instance_initiated_shutdown_behavior\n\n  dynamic \"instance_market_options\" {\n    for_each = var.instance_market_options != null ? [var.instance_market_options] : []\n\n    content {\n      market_type = instance_market_options.value.market_type\n\n      dynamic \"spot_options\" {\n        for_each = instance_market_options.value.spot_options != null ? [instance_market_options.value.spot_options] : []\n\n        content {\n          block_duration_minutes         = spot_options.value.block_duration_minutes\n          instance_interruption_behavior = spot_options.value.instance_interruption_behavior\n          max_price                      = spot_options.value.max_price\n          spot_instance_type             = spot_options.value.spot_instance_type\n          valid_until                    = spot_options.value.valid_until\n        }\n      }\n    }\n  }\n\n  dynamic \"instance_requirements\" {\n    for_each = var.instance_requirements != null ? [var.instance_requirements] : []\n\n    content {\n      dynamic \"accelerator_count\" {\n        for_each = instance_requirements.value.accelerator_count != null ? [instance_requirements.value.accelerator_count] : []\n\n        content {\n          max = accelerator_count.value.max\n          min = accelerator_count.value.min\n        }\n      }\n\n      accelerator_manufacturers = instance_requirements.value.accelerator_manufacturers\n      accelerator_names         = instance_requirements.value.accelerator_names\n\n      dynamic \"accelerator_total_memory_mib\" {\n        for_each = instance_requirements.value.accelerator_total_memory_mib != null ? [instance_requirements.value.accelerator_total_memory_mib] : []\n\n        content {\n          max = accelerator_total_memory_mib.value.max\n          min = accelerator_total_memory_mib.value.min\n        }\n      }\n\n      accelerator_types      = instance_requirements.value.accelerator_types\n      allowed_instance_types = instance_requirements.value.allowed_instance_types\n      bare_metal             = instance_requirements.value.bare_metal\n\n      dynamic \"baseline_ebs_bandwidth_mbps\" {\n        for_each = instance_requirements.value.baseline_ebs_bandwidth_mbps != null ? [instance_requirements.value.baseline_ebs_bandwidth_mbps] : []\n\n        content {\n          max = baseline_ebs_bandwidth_mbps.value.max\n          min = baseline_ebs_bandwidth_mbps.value.min\n        }\n      }\n\n      burstable_performance                                   = instance_requirements.value.burstable_performance\n      cpu_manufacturers                                       = instance_requirements.value.cpu_manufacturers\n      excluded_instance_types                                 = instance_requirements.value.excluded_instance_types\n      instance_generations                                    = instance_requirements.value.instance_generations\n      local_storage                                           = instance_requirements.value.local_storage\n      local_storage_types                                     = instance_requirements.value.local_storage_types\n      max_spot_price_as_percentage_of_optimal_on_demand_price = instance_requirements.value.max_spot_price_as_percentage_of_optimal_on_demand_price\n\n      dynamic \"memory_gib_per_vcpu\" {\n        for_each = instance_requirements.value.memory_gib_per_vcpu != null ? [instance_requirements.value.memory_gib_per_vcpu] : []\n\n        content {\n          max = memory_gib_per_vcpu.value.max\n          min = memory_gib_per_vcpu.value.min\n        }\n      }\n\n      dynamic \"memory_mib\" {\n        for_each = instance_requirements.value.memory_mib != null ? [instance_requirements.value.memory_mib] : []\n\n        content {\n          max = memory_mib.value.max\n          min = memory_mib.value.min\n        }\n      }\n\n      dynamic \"network_interface_count\" {\n        for_each = instance_requirements.value.network_interface_count != null ? [instance_requirements.value.network_interface_count] : []\n\n        content {\n          max = network_interface_count.value.max\n          min = network_interface_count.value.min\n        }\n      }\n\n      on_demand_max_price_percentage_over_lowest_price = instance_requirements.value.on_demand_max_price_percentage_over_lowest_price\n      require_hibernate_support                        = instance_requirements.value.require_hibernate_support\n      spot_max_price_percentage_over_lowest_price      = instance_requirements.value.spot_max_price_percentage_over_lowest_price\n\n      dynamic \"total_local_storage_gb\" {\n        for_each = instance_requirements.value.total_local_storage_gb != null ? [instance_requirements.value.total_local_storage_gb] : []\n\n        content {\n          max = total_local_storage_gb.value.max\n          min = total_local_storage_gb.value.min\n        }\n      }\n\n      dynamic \"vcpu_count\" {\n        for_each = instance_requirements.value.vcpu_count != null ? [instance_requirements.value.vcpu_count] : []\n\n        content {\n          max = vcpu_count.value.max\n          min = vcpu_count.value.min\n        }\n      }\n    }\n  }\n\n  instance_type = var.instance_requirements != null ? null : var.instance_type\n  kernel_id     = var.kernel_id\n  key_name      = var.key_name\n\n  dynamic \"license_specification\" {\n    for_each = var.license_specifications != null ? var.license_specifications : []\n\n    content {\n      license_configuration_arn = license_specification.value.license_configuration_arn\n    }\n  }\n\n  dynamic \"maintenance_options\" {\n    for_each = var.maintenance_options != null ? [var.maintenance_options] : []\n\n    content {\n      auto_recovery = maintenance_options.value.auto_recovery\n    }\n  }\n\n  dynamic \"metadata_options\" {\n    for_each = [var.metadata_options]\n\n    content {\n      http_endpoint               = metadata_options.value.http_endpoint\n      http_protocol_ipv6          = metadata_options.value.http_protocol_ipv6\n      http_put_response_hop_limit = metadata_options.value.http_put_response_hop_limit\n      http_tokens                 = metadata_options.value.http_tokens\n      instance_metadata_tags      = metadata_options.value.instance_metadata_tags\n    }\n  }\n\n  dynamic \"monitoring\" {\n    for_each = var.enable_monitoring ? [1] : []\n\n    content {\n      enabled = var.enable_monitoring\n    }\n  }\n\n  name        = var.launch_template_use_name_prefix ? null : local.launch_template_name\n  name_prefix = var.launch_template_use_name_prefix ? \"${local.launch_template_name}-\" : null\n\n  dynamic \"network_interfaces\" {\n    for_each = length(local.network_interfaces) > 0 ? local.network_interfaces : []\n\n    content {\n      associate_carrier_ip_address = network_interfaces.value.associate_carrier_ip_address\n      associate_public_ip_address  = network_interfaces.value.associate_public_ip_address\n\n      dynamic \"connection_tracking_specification\" {\n        for_each = network_interfaces.value.connection_tracking_specification != null ? [network_interfaces.value.connection_tracking_specification] : []\n\n        content {\n          tcp_established_timeout = connection_tracking_specification.value.tcp_established_timeout\n          udp_stream_timeout      = connection_tracking_specification.value.udp_stream_timeout\n          udp_timeout             = connection_tracking_specification.value.udp_timeout\n        }\n      }\n\n      delete_on_termination = network_interfaces.value.delete_on_termination\n      description           = network_interfaces.value.description\n      device_index          = network_interfaces.value.device_index\n\n      dynamic \"ena_srd_specification\" {\n        for_each = network_interfaces.value.ena_srd_specification != null ? [network_interfaces.value.ena_srd_specification] : []\n\n        content {\n          ena_srd_enabled = ena_srd_specification.value.ena_srd_enabled\n\n          dynamic \"ena_srd_udp_specification\" {\n            for_each = ena_srd_specification.value.ena_srd_udp_specification != null ? [ena_srd_specification.value.ena_srd_udp_specification] : []\n\n            content {\n              ena_srd_udp_enabled = ena_srd_udp_specification.value.ena_srd_udp_enabled\n            }\n          }\n        }\n      }\n\n      interface_type       = network_interfaces.value.interface_type\n      ipv4_address_count   = network_interfaces.value.ipv4_address_count\n      ipv4_addresses       = network_interfaces.value.ipv4_addresses\n      ipv4_prefix_count    = network_interfaces.value.ipv4_prefix_count\n      ipv4_prefixes        = network_interfaces.value.ipv4_prefixes\n      ipv6_address_count   = network_interfaces.value.ipv6_address_count\n      ipv6_addresses       = network_interfaces.value.ipv6_addresses\n      ipv6_prefix_count    = network_interfaces.value.ipv6_prefix_count\n      ipv6_prefixes        = network_interfaces.value.ipv6_prefixes\n      network_card_index   = network_interfaces.value.network_card_index\n      network_interface_id = network_interfaces.value.network_interface_id\n      primary_ipv6         = network_interfaces.value.primary_ipv6\n      private_ip_address   = network_interfaces.value.private_ip_address\n      # Ref: https://github.com/hashicorp/terraform-provider-aws/issues/4570\n      security_groups = compact(concat(network_interfaces.value.security_groups, local.security_group_ids))\n      # Set on EKS managed node group, will fail if set here\n      # https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-basics\n      # subnet_id       = try(network_interfaces.value.subnet_id, null)\n    }\n  }\n\n  dynamic \"placement\" {\n    for_each = var.placement != null || local.create_placement_group ? [var.placement] : []\n\n    content {\n      affinity                = try(placement.value.affinity, null)\n      availability_zone       = try(placement.value.availability_zone, null)\n      group_name              = try(aws_placement_group.this[0].name, placement.value.group_name)\n      host_id                 = try(placement.value.host_id, null)\n      host_resource_group_arn = try(placement.value.host_resource_group_arn, null)\n      partition_number        = try(placement.value.partition_number, null)\n      spread_domain           = try(placement.value.spread_domain, null)\n      tenancy                 = try(placement.value.tenancy, null)\n    }\n  }\n\n  dynamic \"private_dns_name_options\" {\n    for_each = var.private_dns_name_options != null ? [var.private_dns_name_options] : []\n\n    content {\n      enable_resource_name_dns_aaaa_record = private_dns_name_options.value.enable_resource_name_dns_aaaa_record\n      enable_resource_name_dns_a_record    = private_dns_name_options.value.enable_resource_name_dns_a_record\n      hostname_type                        = private_dns_name_options.value.hostname_type\n    }\n  }\n\n  ram_disk_id = var.ram_disk_id\n\n  dynamic \"tag_specifications\" {\n    for_each = toset(var.tag_specifications)\n\n    content {\n      resource_type = tag_specifications.key\n      tags          = merge(var.tags, { Name = var.name }, var.launch_template_tags)\n    }\n  }\n\n  update_default_version = var.update_launch_template_default_version\n  user_data              = module.user_data.user_data\n  vpc_security_group_ids = length(local.network_interfaces) > 0 ? [] : local.security_group_ids\n\n  tags = var.tags\n\n  # Prevent premature access of policies by pods that\n  # require permissions on create/destroy that depend on nodes\n  depends_on = [\n    aws_iam_role_policy_attachment.this,\n    aws_iam_role_policy_attachment.additional,\n  ]\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_111", "ruleIndex": 13, "level": "error", "attachments": [], "message": {"text": "Ensure IAM policies does not allow write access without constraints"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/node_groups.tf"}, "region": {"startLine": 30, "endLine": 50, "snippet": {"text": "data \"aws_iam_policy_document\" \"cni_ipv6_policy\" {\n  count = var.create && var.create_cni_ipv6_iam_policy ? 1 : 0\n\n  statement {\n    sid = \"AssignDescribe\"\n    actions = [\n      \"ec2:AssignIpv6Addresses\",\n      \"ec2:DescribeInstances\",\n      \"ec2:DescribeTags\",\n      \"ec2:DescribeNetworkInterfaces\",\n      \"ec2:DescribeInstanceTypes\"\n    ]\n    resources = [\"*\"]\n  }\n\n  statement {\n    sid       = \"CreateTags\"\n    actions   = [\"ec2:CreateTags\"]\n    resources = [\"arn:${local.partition}:ec2:*:*:network-interface/*\"]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_356", "ruleIndex": 14, "level": "error", "attachments": [], "message": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/node_groups.tf"}, "region": {"startLine": 30, "endLine": 50, "snippet": {"text": "data \"aws_iam_policy_document\" \"cni_ipv6_policy\" {\n  count = var.create && var.create_cni_ipv6_iam_policy ? 1 : 0\n\n  statement {\n    sid = \"AssignDescribe\"\n    actions = [\n      \"ec2:AssignIpv6Addresses\",\n      \"ec2:DescribeInstances\",\n      \"ec2:DescribeTags\",\n      \"ec2:DescribeNetworkInterfaces\",\n      \"ec2:DescribeInstanceTypes\"\n    ]\n    resources = [\"*\"]\n  }\n\n  statement {\n    sid       = \"CreateTags\"\n    actions   = [\"ec2:CreateTags\"]\n    resources = [\"arn:${local.partition}:ec2:*:*:network-interface/*\"]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_111", "ruleIndex": 13, "level": "error", "attachments": [], "message": {"text": "Ensure IAM policies does not allow write access without constraints"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/node_groups.tf"}, "region": {"startLine": 30, "endLine": 50, "snippet": {"text": "data \"aws_iam_policy_document\" \"cni_ipv6_policy\" {\n  count = var.create && var.create_cni_ipv6_iam_policy ? 1 : 0\n\n  statement {\n    sid = \"AssignDescribe\"\n    actions = [\n      \"ec2:AssignIpv6Addresses\",\n      \"ec2:DescribeInstances\",\n      \"ec2:DescribeTags\",\n      \"ec2:DescribeNetworkInterfaces\",\n      \"ec2:DescribeInstanceTypes\"\n    ]\n    resources = [\"*\"]\n  }\n\n  statement {\n    sid       = \"CreateTags\"\n    actions   = [\"ec2:CreateTags\"]\n    resources = [\"arn:${local.partition}:ec2:*:*:network-interface/*\"]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_AWS_356", "ruleIndex": 14, "level": "error", "attachments": [], "message": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/node_groups.tf"}, "region": {"startLine": 30, "endLine": 50, "snippet": {"text": "data \"aws_iam_policy_document\" \"cni_ipv6_policy\" {\n  count = var.create && var.create_cni_ipv6_iam_policy ? 1 : 0\n\n  statement {\n    sid = \"AssignDescribe\"\n    actions = [\n      \"ec2:AssignIpv6Addresses\",\n      \"ec2:DescribeInstances\",\n      \"ec2:DescribeTags\",\n      \"ec2:DescribeNetworkInterfaces\",\n      \"ec2:DescribeInstanceTypes\"\n    ]\n    resources = [\"*\"]\n  }\n\n  statement {\n    sid       = \"CreateTags\"\n    actions   = [\"ec2:CreateTags\"]\n    resources = [\"arn:${local.partition}:ec2:*:*:network-interface/*\"]\n  }\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/eks-fargate-profile/main.tf"}, "region": {"startLine": 124, "endLine": 148, "snippet": {"text": "module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 6.0\"\n\n  name = local.name\n  cidr = local.vpc_cidr\n\n  azs             = local.azs\n  private_subnets = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 4, k)]\n  public_subnets  = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 48)]\n  intra_subnets   = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 52)]\n\n  enable_nat_gateway = true\n  single_nat_gateway = true\n\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = 1\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = 1\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_AWS_355", "ruleIndex": 15, "level": "error", "attachments": [], "message": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/eks-fargate-profile/main.tf"}, "region": {"startLine": 150, "endLine": 165, "snippet": {"text": "resource \"aws_iam_policy\" \"additional\" {\n  name = \"${local.name}-additional\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = [\n          \"ec2:Describe*\",\n        ]\n        Effect   = \"Allow\"\n        Resource = \"*\"\n      },\n    ]\n  })\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/eks-managed-node-group/main.tf"}, "region": {"startLine": 467, "endLine": 500, "snippet": {"text": "module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 6.0\"\n\n  name = local.name\n  cidr = local.vpc_cidr\n\n  azs             = local.azs\n  private_subnets = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 4, k)]\n  public_subnets  = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 48)]\n  intra_subnets   = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 52)]\n\n  enable_nat_gateway     = true\n  single_nat_gateway     = true\n  enable_ipv6            = true\n  create_egress_only_igw = true\n\n  public_subnet_ipv6_prefixes                    = [0, 1, 2]\n  public_subnet_assign_ipv6_address_on_creation  = true\n  private_subnet_ipv6_prefixes                   = [3, 4, 5]\n  private_subnet_assign_ipv6_address_on_creation = true\n  intra_subnet_ipv6_prefixes                     = [6, 7, 8]\n  intra_subnet_assign_ipv6_address_on_creation   = true\n\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = 1\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = 1\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/eks-managed-node-group/main.tf"}, "region": {"startLine": 502, "endLine": 512, "snippet": {"text": "module \"aws_vpc_cni_ipv6_pod_identity\" {\n  source  = \"terraform-aws-modules/eks-pod-identity/aws\"\n  version = \"~> 1.6\"\n\n  name = \"aws-vpc-cni-ipv6\"\n\n  attach_aws_vpc_cni_policy = true\n  aws_vpc_cni_enable_ipv6   = true\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/eks-managed-node-group/main.tf"}, "region": {"startLine": 514, "endLine": 536, "snippet": {"text": "module \"ebs_kms_key\" {\n  source  = \"terraform-aws-modules/kms/aws\"\n  version = \"~> 4.0\"\n\n  description = \"Customer managed key to encrypt EKS managed node group volumes\"\n\n  # Policy\n  key_administrators = [\n    data.aws_caller_identity.current.arn\n  ]\n\n  key_service_roles_for_autoscaling = [\n    # required for the ASG to manage encrypted volumes for nodes\n    \"arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/aws-service-role/autoscaling.amazonaws.com/AWSServiceRoleForAutoScaling\",\n    # required for the cluster / persistentvolume-controller to create encrypted PVCs\n    module.eks.cluster_iam_role_arn,\n  ]\n\n  # Aliases\n  aliases = [\"eks/${local.name}/ebs\"]\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/eks-managed-node-group/main.tf"}, "region": {"startLine": 538, "endLine": 546, "snippet": {"text": "module \"key_pair\" {\n  source  = \"terraform-aws-modules/key-pair/aws\"\n  version = \"~> 2.0\"\n\n  key_name_prefix    = local.name\n  create_private_key = true\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_AWS_23", "ruleIndex": 5, "level": "error", "attachments": [], "message": {"text": "Ensure every security group and rule has a description"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/eks-managed-node-group/main.tf"}, "region": {"startLine": 548, "endLine": 570, "snippet": {"text": "resource \"aws_security_group\" \"remote_access\" {\n  name_prefix = \"${local.name}-remote-access\"\n  description = \"Allow remote SSH access\"\n  vpc_id      = module.vpc.vpc_id\n\n  ingress {\n    description = \"SSH access\"\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"10.0.0.0/8\"]\n  }\n\n  egress {\n    from_port        = 0\n    to_port          = 0\n    protocol         = \"-1\"\n    cidr_blocks      = [\"0.0.0.0/0\"]\n    ipv6_cidr_blocks = [\"::/0\"]\n  }\n\n  tags = merge(local.tags, { Name = \"${local.name}-remote\" })\n}\n"}}}}]}, {"ruleId": "CKV_AWS_382", "ruleIndex": 16, "level": "error", "attachments": [], "message": {"text": "Ensure no security groups allow egress from 0.0.0.0:0 to port -1"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/eks-managed-node-group/main.tf"}, "region": {"startLine": 548, "endLine": 570, "snippet": {"text": "resource \"aws_security_group\" \"remote_access\" {\n  name_prefix = \"${local.name}-remote-access\"\n  description = \"Allow remote SSH access\"\n  vpc_id      = module.vpc.vpc_id\n\n  ingress {\n    description = \"SSH access\"\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"10.0.0.0/8\"]\n  }\n\n  egress {\n    from_port        = 0\n    to_port          = 0\n    protocol         = \"-1\"\n    cidr_blocks      = [\"0.0.0.0/0\"]\n    ipv6_cidr_blocks = [\"::/0\"]\n  }\n\n  tags = merge(local.tags, { Name = \"${local.name}-remote\" })\n}\n"}}}}]}, {"ruleId": "CKV_AWS_355", "ruleIndex": 15, "level": "error", "attachments": [], "message": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/eks-managed-node-group/main.tf"}, "region": {"startLine": 572, "endLine": 590, "snippet": {"text": "resource \"aws_iam_policy\" \"node_additional\" {\n  name        = \"${local.name}-additional\"\n  description = \"Example usage of node additional policy\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = [\n          \"ec2:Describe*\",\n        ]\n        Effect   = \"Allow\"\n        Resource = \"*\"\n      },\n    ]\n  })\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/self-managed-node-group/main.tf"}, "region": {"startLine": 379, "endLine": 403, "snippet": {"text": "module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 6.0\"\n\n  name = local.name\n  cidr = local.vpc_cidr\n\n  azs             = local.azs\n  private_subnets = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 4, k)]\n  public_subnets  = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 48)]\n  intra_subnets   = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 52)]\n\n  enable_nat_gateway = true\n  single_nat_gateway = true\n\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = 1\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = 1\n  }\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/self-managed-node-group/main.tf"}, "region": {"startLine": 405, "endLine": 415, "snippet": {"text": "module \"aws_vpc_cni_ipv4_pod_identity\" {\n  source  = \"terraform-aws-modules/eks-pod-identity/aws\"\n  version = \"~> 1.6\"\n\n  name = \"aws-vpc-cni-ipv4\"\n\n  attach_aws_vpc_cni_policy = true\n  aws_vpc_cni_enable_ipv4   = true\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/self-managed-node-group/main.tf"}, "region": {"startLine": 437, "endLine": 445, "snippet": {"text": "module \"key_pair\" {\n  source  = \"terraform-aws-modules/key-pair/aws\"\n  version = \"~> 2.0\"\n\n  key_name_prefix    = local.name\n  create_private_key = true\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/self-managed-node-group/main.tf"}, "region": {"startLine": 447, "endLine": 469, "snippet": {"text": "module \"ebs_kms_key\" {\n  source  = \"terraform-aws-modules/kms/aws\"\n  version = \"~> 4.0\"\n\n  description = \"Customer managed key to encrypt EKS managed node group volumes\"\n\n  # Policy\n  key_administrators = [\n    data.aws_caller_identity.current.arn\n  ]\n\n  key_service_roles_for_autoscaling = [\n    # required for the ASG to manage encrypted volumes for nodes\n    \"arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/aws-service-role/autoscaling.amazonaws.com/AWSServiceRoleForAutoScaling\",\n    # required for the cluster / persistentvolume-controller to create encrypted PVCs\n    module.eks.cluster_iam_role_arn,\n  ]\n\n  # Aliases\n  aliases = [\"eks/${local.name}/ebs\"]\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_TF_1", "ruleIndex": 0, "level": "error", "attachments": [], "message": {"text": "Ensure Terraform module sources use a commit hash"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/self-managed-node-group/main.tf"}, "region": {"startLine": 471, "endLine": 481, "snippet": {"text": "module \"kms\" {\n  source  = \"terraform-aws-modules/kms/aws\"\n  version = \"~> 4.0\"\n\n  aliases               = [\"eks/${local.name}\"]\n  description           = \"${local.name} cluster encryption key\"\n  enable_default_policy = true\n  key_owners            = [data.aws_caller_identity.current.arn]\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV_AWS_355", "ruleIndex": 15, "level": "error", "attachments": [], "message": {"text": "Ensure no IAM policies documents allow \"*\" as a statement's resource for restrictable actions"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/self-managed-node-group/main.tf"}, "region": {"startLine": 483, "endLine": 501, "snippet": {"text": "resource \"aws_iam_policy\" \"additional\" {\n  name        = \"${local.name}-additional\"\n  description = \"Example usage of node additional policy\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = [\n          \"ec2:Describe*\",\n        ]\n        Effect   = \"Allow\"\n        Resource = \"*\"\n      },\n    ]\n  })\n\n  tags = local.tags\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_41", "ruleIndex": 17, "level": "error", "attachments": [], "message": {"text": "Ensure an IAM role is attached to EC2 instance"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 97, "endLine": 118, "snippet": {"text": "resource \"aws_instance\" \"hybrid_node\" {\n  provider = aws.remote\n\n  for_each = { one = 0, two = 1 }\n\n  ami                         = data.aws_ami.hybrid_node.id\n  associate_public_ip_address = true\n  instance_type               = \"m5.large\"\n\n  # Block IMDS to make instance look less like EC2 and more like vanilla VM\n  metadata_options {\n    http_endpoint = \"disabled\"\n  }\n\n  vpc_security_group_ids = [aws_security_group.remote_node.id]\n  subnet_id              = element(module.remote_node_vpc.public_subnets, each.value)\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_41", "ruleIndex": 17, "level": "error", "attachments": [], "message": {"text": "Ensure an IAM role is attached to EC2 instance"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-hybrid-nodes/remote.tf"}, "region": {"startLine": 97, "endLine": 118, "snippet": {"text": "resource \"aws_instance\" \"hybrid_node\" {\n  provider = aws.remote\n\n  for_each = { one = 0, two = 1 }\n\n  ami                         = data.aws_ami.hybrid_node.id\n  associate_public_ip_address = true\n  instance_type               = \"m5.large\"\n\n  # Block IMDS to make instance look less like EC2 and more like vanilla VM\n  metadata_options {\n    http_endpoint = \"disabled\"\n  }\n\n  vpc_security_group_ids = [aws_security_group.remote_node.id]\n  subnet_id              = element(module.remote_node_vpc.public_subnets, each.value)\n\n  tags = merge(\n    local.tags,\n    { Name = \"hybrid-node-${each.key}\" }\n  )\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_5", "ruleIndex": 18, "level": "error", "attachments": [], "message": {"text": "Ensure that Security Groups are attached to another resource"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 391, "endLine": 410, "snippet": {"text": "resource \"aws_security_group\" \"cluster\" {\n  count = local.create_security_group ? 1 : 0\n\n  region = var.region\n\n  name        = var.security_group_use_name_prefix ? null : local.security_group_name\n  name_prefix = var.security_group_use_name_prefix ? \"${local.security_group_name}${var.prefix_separator}\" : null\n  description = var.security_group_description\n  vpc_id      = var.vpc_id\n\n  tags = merge(\n    var.tags,\n    { \"Name\" = local.security_group_name },\n    var.security_group_tags\n  )\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_5", "ruleIndex": 18, "level": "error", "attachments": [], "message": {"text": "Ensure that Security Groups are attached to another resource"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 391, "endLine": 410, "snippet": {"text": "resource \"aws_security_group\" \"cluster\" {\n  count = local.create_security_group ? 1 : 0\n\n  region = var.region\n\n  name        = var.security_group_use_name_prefix ? null : local.security_group_name\n  name_prefix = var.security_group_use_name_prefix ? \"${local.security_group_name}${var.prefix_separator}\" : null\n  description = var.security_group_description\n  vpc_id      = var.vpc_id\n\n  tags = merge(\n    var.tags,\n    { \"Name\" = local.security_group_name },\n    var.security_group_tags\n  )\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_5", "ruleIndex": 18, "level": "error", "attachments": [], "message": {"text": "Ensure that Security Groups are attached to another resource"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 391, "endLine": 410, "snippet": {"text": "resource \"aws_security_group\" \"cluster\" {\n  count = local.create_security_group ? 1 : 0\n\n  region = var.region\n\n  name        = var.security_group_use_name_prefix ? null : local.security_group_name\n  name_prefix = var.security_group_use_name_prefix ? \"${local.security_group_name}${var.prefix_separator}\" : null\n  description = var.security_group_description\n  vpc_id      = var.vpc_id\n\n  tags = merge(\n    var.tags,\n    { \"Name\" = local.security_group_name },\n    var.security_group_tags\n  )\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_5", "ruleIndex": 18, "level": "error", "attachments": [], "message": {"text": "Ensure that Security Groups are attached to another resource"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/main.tf"}, "region": {"startLine": 391, "endLine": 410, "snippet": {"text": "resource \"aws_security_group\" \"cluster\" {\n  count = local.create_security_group ? 1 : 0\n\n  region = var.region\n\n  name        = var.security_group_use_name_prefix ? null : local.security_group_name\n  name_prefix = var.security_group_use_name_prefix ? \"${local.security_group_name}${var.prefix_separator}\" : null\n  description = var.security_group_description\n  vpc_id      = var.vpc_id\n\n  tags = merge(\n    var.tags,\n    { \"Name\" = local.security_group_name },\n    var.security_group_tags\n  )\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_5", "ruleIndex": 18, "level": "error", "attachments": [], "message": {"text": "Ensure that Security Groups are attached to another resource"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/self-managed-node-group/main.tf"}, "region": {"startLine": 1041, "endLine": 1060, "snippet": {"text": "resource \"aws_security_group\" \"this\" {\n  count = local.create_security_group ? 1 : 0\n\n  region = var.region\n\n  name        = var.security_group_use_name_prefix ? null : local.security_group_name\n  name_prefix = var.security_group_use_name_prefix ? \"${local.security_group_name}-\" : null\n  description = var.security_group_description\n  vpc_id      = data.aws_subnet.this[0].vpc_id\n\n  tags = merge(\n    var.tags,\n    { \"Name\" = local.security_group_name },\n    var.security_group_tags\n  )\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_5", "ruleIndex": 18, "level": "error", "attachments": [], "message": {"text": "Ensure that Security Groups are attached to another resource"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/self-managed-node-group/main.tf"}, "region": {"startLine": 1041, "endLine": 1060, "snippet": {"text": "resource \"aws_security_group\" \"this\" {\n  count = local.create_security_group ? 1 : 0\n\n  region = var.region\n\n  name        = var.security_group_use_name_prefix ? null : local.security_group_name\n  name_prefix = var.security_group_use_name_prefix ? \"${local.security_group_name}-\" : null\n  description = var.security_group_description\n  vpc_id      = data.aws_subnet.this[0].vpc_id\n\n  tags = merge(\n    var.tags,\n    { \"Name\" = local.security_group_name },\n    var.security_group_tags\n  )\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_5", "ruleIndex": 18, "level": "error", "attachments": [], "message": {"text": "Ensure that Security Groups are attached to another resource"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/self-managed-node-group/main.tf"}, "region": {"startLine": 1041, "endLine": 1060, "snippet": {"text": "resource \"aws_security_group\" \"this\" {\n  count = local.create_security_group ? 1 : 0\n\n  region = var.region\n\n  name        = var.security_group_use_name_prefix ? null : local.security_group_name\n  name_prefix = var.security_group_use_name_prefix ? \"${local.security_group_name}-\" : null\n  description = var.security_group_description\n  vpc_id      = data.aws_subnet.this[0].vpc_id\n\n  tags = merge(\n    var.tags,\n    { \"Name\" = local.security_group_name },\n    var.security_group_tags\n  )\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_5", "ruleIndex": 18, "level": "error", "attachments": [], "message": {"text": "Ensure that Security Groups are attached to another resource"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/modules/self-managed-node-group/main.tf"}, "region": {"startLine": 1041, "endLine": 1060, "snippet": {"text": "resource \"aws_security_group\" \"this\" {\n  count = local.create_security_group ? 1 : 0\n\n  region = var.region\n\n  name        = var.security_group_use_name_prefix ? null : local.security_group_name\n  name_prefix = var.security_group_use_name_prefix ? \"${local.security_group_name}-\" : null\n  description = var.security_group_description\n  vpc_id      = data.aws_subnet.this[0].vpc_id\n\n  tags = merge(\n    var.tags,\n    { \"Name\" = local.security_group_name },\n    var.security_group_tags\n  )\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_5", "ruleIndex": 18, "level": "error", "attachments": [], "message": {"text": "Ensure that Security Groups are attached to another resource"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/node_groups.tf"}, "region": {"startLine": 177, "endLine": 199, "snippet": {"text": "resource \"aws_security_group\" \"node\" {\n  count = local.create_node_sg ? 1 : 0\n\n  region = var.region\n\n  name        = var.node_security_group_use_name_prefix ? null : local.node_sg_name\n  name_prefix = var.node_security_group_use_name_prefix ? \"${local.node_sg_name}${var.prefix_separator}\" : null\n  description = var.node_security_group_description\n  vpc_id      = var.vpc_id\n\n  tags = merge(\n    var.tags,\n    {\n      \"Name\"                              = local.node_sg_name\n      \"kubernetes.io/cluster/${var.name}\" = \"owned\"\n    },\n    var.node_security_group_tags\n  )\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n"}}}}]}, {"ruleId": "CKV2_AWS_5", "ruleIndex": 18, "level": "error", "attachments": [], "message": {"text": "Ensure that Security Groups are attached to another resource"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/tests/eks-managed-node-group/main.tf"}, "region": {"startLine": 548, "endLine": 570, "snippet": {"text": "resource \"aws_security_group\" \"remote_access\" {\n  name_prefix = \"${local.name}-remote-access\"\n  description = \"Allow remote SSH access\"\n  vpc_id      = module.vpc.vpc_id\n\n  ingress {\n    description = \"SSH access\"\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"10.0.0.0/8\"]\n  }\n\n  egress {\n    from_port        = 0\n    to_port          = 0\n    protocol         = \"-1\"\n    cidr_blocks      = [\"0.0.0.0/0\"]\n    ipv6_cidr_blocks = [\"::/0\"]\n  }\n\n  tags = merge(local.tags, { Name = \"${local.name}-remote\" })\n}\n"}}}}]}, {"ruleId": "CKV_K8S_20", "ruleIndex": 19, "level": "error", "attachments": [], "message": {"text": "Containers should not run with allowPrivilegeEscalation"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_30", "ruleIndex": 20, "level": "error", "attachments": [], "message": {"text": "Apply security context to your containers"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_11", "ruleIndex": 21, "level": "error", "attachments": [], "message": {"text": "CPU limits should be set"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_21", "ruleIndex": 22, "level": "error", "attachments": [], "message": {"text": "The default namespace should not be used"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_28", "ruleIndex": 23, "level": "error", "attachments": [], "message": {"text": "Minimize the admission of containers with the NET_RAW capability"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_43", "ruleIndex": 24, "level": "error", "attachments": [], "message": {"text": "Image should use digest"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_15", "ruleIndex": 25, "level": "error", "attachments": [], "message": {"text": "Image Pull Policy should be Always"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_8", "ruleIndex": 26, "level": "error", "attachments": [], "message": {"text": "Liveness Probe Should be Configured"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_13", "ruleIndex": 27, "level": "error", "attachments": [], "message": {"text": "Memory limits should be set"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_12", "ruleIndex": 28, "level": "error", "attachments": [], "message": {"text": "Memory requests should be set"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_37", "ruleIndex": 29, "level": "error", "attachments": [], "message": {"text": "Minimize the admission of containers with capabilities assigned"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_29", "ruleIndex": 30, "level": "error", "attachments": [], "message": {"text": "Apply security context to your pods and containers"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_9", "ruleIndex": 31, "level": "error", "attachments": [], "message": {"text": "Readiness Probe Should be Configured"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_22", "ruleIndex": 32, "level": "error", "attachments": [], "message": {"text": "Use read-only filesystem for containers where possible"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_23", "ruleIndex": 33, "level": "error", "attachments": [], "message": {"text": "Minimize the admission of root containers"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_40", "ruleIndex": 34, "level": "error", "attachments": [], "message": {"text": "Containers should run as a high UID to avoid host conflict"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_31", "ruleIndex": 35, "level": "error", "attachments": [], "message": {"text": "Ensure that the seccomp profile is set to docker/default or runtime/default"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_38", "ruleIndex": 36, "level": "error", "attachments": [], "message": {"text": "Ensure that Service Account Tokens are only mounted where necessary"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_20", "ruleIndex": 19, "level": "error", "attachments": [], "message": {"text": "Containers should not run with allowPrivilegeEscalation"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_30", "ruleIndex": 20, "level": "error", "attachments": [], "message": {"text": "Apply security context to your containers"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_11", "ruleIndex": 21, "level": "error", "attachments": [], "message": {"text": "CPU limits should be set"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_21", "ruleIndex": 22, "level": "error", "attachments": [], "message": {"text": "The default namespace should not be used"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_28", "ruleIndex": 23, "level": "error", "attachments": [], "message": {"text": "Minimize the admission of containers with the NET_RAW capability"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_43", "ruleIndex": 24, "level": "error", "attachments": [], "message": {"text": "Image should use digest"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_15", "ruleIndex": 25, "level": "error", "attachments": [], "message": {"text": "Image Pull Policy should be Always"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_8", "ruleIndex": 26, "level": "error", "attachments": [], "message": {"text": "Liveness Probe Should be Configured"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_13", "ruleIndex": 27, "level": "error", "attachments": [], "message": {"text": "Memory limits should be set"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_12", "ruleIndex": 28, "level": "error", "attachments": [], "message": {"text": "Memory requests should be set"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_37", "ruleIndex": 29, "level": "error", "attachments": [], "message": {"text": "Minimize the admission of containers with capabilities assigned"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_29", "ruleIndex": 30, "level": "error", "attachments": [], "message": {"text": "Apply security context to your pods and containers"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_9", "ruleIndex": 31, "level": "error", "attachments": [], "message": {"text": "Readiness Probe Should be Configured"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_22", "ruleIndex": 32, "level": "error", "attachments": [], "message": {"text": "Use read-only filesystem for containers where possible"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_23", "ruleIndex": 33, "level": "error", "attachments": [], "message": {"text": "Minimize the admission of root containers"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_40", "ruleIndex": 34, "level": "error", "attachments": [], "message": {"text": "Containers should run as a high UID to avoid host conflict"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_31", "ruleIndex": 35, "level": "error", "attachments": [], "message": {"text": "Ensure that the seccomp profile is set to docker/default or runtime/default"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV_K8S_38", "ruleIndex": 36, "level": "error", "attachments": [], "message": {"text": "Ensure that Service Account Tokens are only mounted where necessary"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV2_K8S_6", "ruleIndex": 37, "level": "error", "attachments": [], "message": {"text": "Minimize the admission of pods which lack an associated NetworkPolicy"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/eks-auto-mode/deployment.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.10\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV2_K8S_6", "ruleIndex": 37, "level": "error", "attachments": [], "message": {"text": "Minimize the admission of pods which lack an associated NetworkPolicy"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/examples/karpenter/inflate.yaml"}, "region": {"startLine": 1, "endLine": 21, "snippet": {"text": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: inflate\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: inflate\n  template:\n    metadata:\n      labels:\n        app: inflate\n    spec:\n      terminationGracePeriodSeconds: 0\n      containers:\n        - name: inflate\n          image: public.ecr.aws/eks-distro/kubernetes/pause:3.7\n          resources:\n            requests:\n              cpu: 1\n"}}}}]}, {"ruleId": "CKV2_GHA_1", "ruleIndex": 38, "level": "error", "attachments": [], "message": {"text": "Ensure top-level permissions are not set to write-all"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/.github/workflows/lock.yml"}, "region": {"startLine": 1, "endLine": 1, "snippet": {"text": ""}}}}]}, {"ruleId": "CKV2_GHA_1", "ruleIndex": 38, "level": "error", "attachments": [], "message": {"text": "Ensure top-level permissions are not set to write-all"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/.github/workflows/pr-title.yml"}, "region": {"startLine": 1, "endLine": 1, "snippet": {"text": ""}}}}]}, {"ruleId": "CKV2_GHA_1", "ruleIndex": 38, "level": "error", "attachments": [], "message": {"text": "Ensure top-level permissions are not set to write-all"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/.github/workflows/pre-commit.yml"}, "region": {"startLine": 1, "endLine": 1, "snippet": {"text": ""}}}}]}, {"ruleId": "CKV2_GHA_1", "ruleIndex": 38, "level": "error", "attachments": [], "message": {"text": "Ensure top-level permissions are not set to write-all"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/.github/workflows/release.yml"}, "region": {"startLine": 1, "endLine": 1, "snippet": {"text": ""}}}}]}, {"ruleId": "CKV2_GHA_1", "ruleIndex": 38, "level": "error", "attachments": [], "message": {"text": "Ensure top-level permissions are not set to write-all"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "terraform-aws-eks/.github/workflows/stale-actions.yaml"}, "region": {"startLine": 1, "endLine": 1, "snippet": {"text": ""}}}}]}]}]}